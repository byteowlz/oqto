"use client";

import {
	A2UICallCard,
	type FileAttachment,
	FileAttachmentChip,
	FileMentionPopup,
	ReadAloudButton,
	SlashCommandPopup,
	ToolCallCard,
	ToolCallGroup,
	getToolIcon,
} from "@/components/chat";
import { BrailleSpinner } from "@/components/common";
import { getToolSummary } from "@/lib/tool-summaries";
import { useChatContext } from "@/components/contexts/chat-context";
import {
	ContextWindowGauge,
	CopyButton,
	MarkdownRenderer,
} from "@/components/data-display";
import { Button } from "@/components/ui/button";
import {
	ContextMenu,
	ContextMenuContent,
	ContextMenuItem,
	ContextMenuTrigger,
} from "@/components/ui/context-menu";
import { Input } from "@/components/ui/input";
import { DictationOverlay } from "@/components/voice";
import {
	VoiceMenuButton,
	type VoiceMode,
} from "@/components/voice/VoiceMenuButton";
import type { Features, PiModelInfo } from "@/features/chat/api";
import { type A2UISurfaceState, useA2UI } from "@/hooks/use-a2ui";
import { useDictation } from "@/hooks/use-dictation";
import {
	type DisplayMessage,
	type DisplayPart,
	getCachedScrollPosition,
	setCachedScrollPosition,
	useChat,
} from "@/hooks/useChat";
import type { Part, ToolStatus } from "@/lib/canonical-types";
import { useChatVerbosity } from "@/lib/chat-verbosity";
import { extractFileReferenceDetails, getFileTypeInfo } from "@/lib/file-types";
import {
	downloadFileMux,
	readFileMux,
	statPathMux,
	uploadFileMux,
} from "@/lib/mux-files";
import {
	formatSessionDate,
	formatTempId,
	getDisplayPiTitle,
	getTempIdFromSession,
	normalizeWorkspacePath,
	parseAutoGeneratedTitle,
} from "@/lib/session-utils";
import {
	type SlashCommand,
	fuzzyMatch,
	parseSlashInput,
} from "@/lib/slash-commands";
import { cn } from "@/lib/utils";
import { getWsManager } from "@/lib/ws-manager";
import {
	ArrowDown,
	ArrowUp,
	Bot,
	Check,
	Copy,
	ExternalLink,
	FileCode,
	FileImage,
	FileText,
	FileVideo,
	Loader2,
	Paperclip,
	Send,
	StopCircle,
	Trash2,
	User,
} from "lucide-react";
import {
	type ChangeEvent,
	type KeyboardEvent,
	memo,
	startTransition,
	useCallback,
	useEffect,
	useLayoutEffect,
	useMemo,
	useRef,
	useState,
} from "react";
import { useTranslation } from "react-i18next";
import { toast } from "sonner";

// Strip ANSI escape codes from text content (tool output may contain them).
// Uses a single comprehensive regex that handles SGR, CSI, OSC, and literal sequences.
const ANSI_RE =
	// biome-ignore lint: control chars needed for ANSI matching
	/[\x1b\x9b][\[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nq-uy=><~]|\\x1b\[[0-9;]*[A-Za-z]/g;

/**
 * Remove common leading whitespace from text to prevent CommonMark from
 * interpreting 4+-space-indented lines as indented code blocks.
 * Preserves relative indentation and skips lines inside fenced code blocks.
 */
function dedentMarkdown(text: string): string {
	const lines = text.split("\n");
	// Find minimum indent of non-empty lines that are NOT inside fenced code blocks
	let minIndent = Number.POSITIVE_INFINITY;
	let inFence = false;
	for (const line of lines) {
		if (/^[ \t]*```/.test(line)) {
			inFence = !inFence;
			continue;
		}
		if (inFence) continue;
		if (line.trim().length === 0) continue;
		const match = line.match(/^( +)/);
		const indent = match ? match[1].length : 0;
		if (indent < minIndent) minIndent = indent;
	}
	if (minIndent === 0 || minIndent === Number.POSITIVE_INFINITY) return text;
	// Strip the common prefix
	const prefix = new RegExp(`^[ ]{1,${minIndent}}`);
	inFence = false;
	return lines
		.map((line) => {
			if (/^[ \t]*```/.test(line)) {
				inFence = !inFence;
				return line.replace(prefix, "");
			}
			if (inFence) return line;
			return line.replace(prefix, "");
		})
		.join("\n");
}

/** Todo item structure (matching todowrite tool) */
export interface TodoItem {
	id: string;
	content: string;
	status: "pending" | "in_progress" | "completed" | "cancelled";
	priority: "high" | "medium" | "low";
}

type QueuedMessage = {
	id: string;
	text: string;
};

export interface ChatViewProps {
	/** Current locale */
	locale?: "en" | "de";
	/** Class name for container */
	className?: string;
	/** Storage key prefix for cached messages */
	storageKeyPrefix?: string;
	/** Features config (for voice settings) */
	features?: Features | null;
	/** Workspace path for file operations */
	workspacePath?: string | null;
	/** Assistant name to display (user-configured default chat name) */
	assistantName?: string | null;
	/** Hide the internal header (used when embedded in sessions app with external header) */
	hideHeader?: boolean;
	/** Callback to report token usage (for external gauge display) */
	onTokenUsageChange?: (usage: {
		inputTokens: number;
		outputTokens: number;
		maxTokens: number;
	}) => void;
	/** Selected session ID (from sidebar) */
	selectedSessionId?: string | null;
	/** Callback when selection should change (e.g. /new created a session) */
	onSelectedSessionIdChange?: (id: string | null) => void;
	/** Message ID to scroll to (from search results) */
	scrollToMessageId?: string | null;
	/** Callback when scroll target is reached (to clear the target) */
	onScrollToMessageComplete?: () => void;
	/** Callback when a message is sent (for sidebar refresh) */
	onMessageSent?: () => void;
	/** Callback when an assistant message completes (for sidebar refresh) */
	onMessageComplete?: () => void;
	/** Callback when todos change (extracted from Pi todowrite tool calls) */
	onTodosChange?: (todos: TodoItem[]) => void;
	/** Pending file attachment to add (e.g. from canvas "Save & add to chat") */
	pendingFileAttachment?: FileAttachment | null;
	/** Called after the pending file attachment has been consumed */
	onPendingFileAttachmentConsumed?: () => void;
	/** Text to prefill into the chat input (e.g. from browser "Send to chat") */
	pendingChatInput?: string | null;
	/** Called after the pending chat input has been consumed */
	onPendingChatInputConsumed?: () => void;
}

/**
 * Chat view using Pi agent runtime.
 */
export function ChatView({
	locale = "en",
	className,
	storageKeyPrefix,
	features,
	workspacePath,
	assistantName,
	hideHeader = false,
	onTokenUsageChange,
	selectedSessionId,
	onSelectedSessionIdChange,
	scrollToMessageId,
	onScrollToMessageComplete,
	onMessageSent,
	onMessageComplete,
	onTodosChange,
	pendingFileAttachment,
	onPendingFileAttachmentConsumed,
	pendingChatInput,
	onPendingChatInputConsumed,
}: ChatViewProps) {
	const [sendPending, setSendPending] = useState(false);
	const [sendPendingSessionId, setSendPendingSessionId] = useState<
		string | null
	>(null);
	const sendPendingTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(
		null,
	);
	const normalizedWorkspacePath = useMemo(
		() => normalizeWorkspacePath(workspacePath),
		[workspacePath],
	);

	const resolvedStorageKeyPrefix =
		storageKeyPrefix ??
		`oqto:workspacePi:${(normalizedWorkspacePath ?? "default").replace(
			/[^a-zA-Z0-9._-]+/g,
			"_",
		)}`;
	const draftStorageKey = `${resolvedStorageKeyPrefix}:draft`;
	const scrollStorageKey = `${resolvedStorageKeyPrefix}:scrollPosition`;
	const { updateChatSessionTitleLocal, selectedChatFromHistory } =
		useChatContext();
	const sessionMeta = selectedChatFromHistory ?? null;
	const handleMessageComplete = useCallback(() => {
		onMessageComplete?.();
	}, [onMessageComplete]);
	const {
		messages,
		isConnected,
		isStreaming,
		isAwaitingResponse,
		error,
		send,
		appendLocalAssistantMessage,
		abort,
		compact,
		newSession,
		resetSession,
		state: piState,
		refresh,
	} = useChat({
		workspacePath: normalizedWorkspacePath,
		storageKeyPrefix: resolvedStorageKeyPrefix,
		selectedSessionId,
		onSelectedSessionIdChange,
		onMessageComplete: handleMessageComplete,
		onTitleChanged: updateChatSessionTitleLocal,
	});
	// Draft persistence - restore from localStorage on mount.
	// Input value lives in a ref (never in React state) so that
	// keystrokes never trigger a React render of this large component.
	// The textarea uses defaultValue and is fully uncontrolled.
	const inputInitialValue = useMemo(() => {
		if (typeof window === "undefined") return "";
		try {
			return localStorage.getItem(draftStorageKey) || "";
		} catch {
			return "";
		}
	}, [draftStorageKey]);
	const inputValueRef = useRef(inputInitialValue);
	// Lightweight state only for send-button enabled/disabled
	const [canSendInput, setCanSendInput] = useState(!!inputInitialValue.trim());
	// Helper to imperatively set the textarea value and sync ref
	const setInput = useCallback((value: string) => {
		inputValueRef.current = value;
		if (inputRef.current) {
			inputRef.current.value = value;
		}
		startTransition(() => setCanSendInput(!!value.trim()));
	}, []);
	const [fileAttachments, setFileAttachments] = useState<FileAttachment[]>([]);

	// Consume pending file attachment from external source (e.g. canvas)
	useEffect(() => {
		if (pendingFileAttachment) {
			setFileAttachments((prev) => {
				// Avoid duplicates
				if (prev.some((a) => a.path === pendingFileAttachment.path))
					return prev;
				return [...prev, pendingFileAttachment];
			});
			onPendingFileAttachmentConsumed?.();
		}
	}, [pendingFileAttachment, onPendingFileAttachmentConsumed]);

	const [queuedMessages, setQueuedMessages] = useState<QueuedMessage[]>([]);
	const messagesEndRef = useRef<HTMLDivElement>(null);
	const messagesContainerRef = useRef<HTMLDivElement>(null);
	const inputRef = useRef<HTMLTextAreaElement>(null);
	const fileInputRef = useRef<HTMLInputElement>(null);
	const queueSendInFlightRef = useRef(false);
	const queueCooldownRef = useRef<number | null>(null);
	const draftSaveTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(
		null,
	);
	const initialScrollDoneRef = useRef(false);

	// Consume pending chat input from external source (e.g. browser "Send to chat")
	// biome-ignore lint/correctness/useExhaustiveDependencies: setInput is stable setState
	useEffect(() => {
		if (pendingChatInput) {
			setInput(pendingChatInput);
			onPendingChatInputConsumed?.();
			// Focus the input after a tick so the user can review/edit
			setTimeout(() => {
				inputRef.current?.focus();
			}, 100);
		}
	}, [pendingChatInput, onPendingChatInputConsumed]);

	// biome-ignore lint/correctness/useExhaustiveDependencies: setInput is stable setState
	useEffect(() => {
		if (typeof window === "undefined") return;
		try {
			setInput(localStorage.getItem(draftStorageKey) || "");
		} catch {
			setInput("");
		}
	}, [draftStorageKey]);
	const sendPendingRef = useRef(sendPending);
	sendPendingRef.current = sendPending;
	useEffect(() => {
		// Reset queue when session changes; use void to reference the dep
		void selectedSessionId;
		setQueuedMessages([]);
		if (!sendPendingRef.current) {
			setSendPendingSessionId(null);
		}
	}, [selectedSessionId]);
	useEffect(() => {
		if (!selectedSessionId || !piState?.sessionName) return;
		// Only apply the title if piState actually belongs to this session.
		// If piState has no sessionId, we can't verify ownership — skip to
		// avoid applying a stale title from a previous session.
		if (!piState.sessionId || piState.sessionId !== selectedSessionId) return;
		// Parse the raw Pi title to strip "workspace:" prefix and "[readable-id]" suffix
		const parsed = parseAutoGeneratedTitle(piState.sessionName);
		updateChatSessionTitleLocal(
			selectedSessionId,
			parsed.title || piState.sessionName,
			parsed.readable_id,
		);
	}, [
		piState?.sessionName,
		piState?.sessionId,
		selectedSessionId,
		updateChatSessionTitleLocal,
	]);
	useEffect(() => {
		if (isStreaming || isAwaitingResponse) {
			setSendPending(false);
			setSendPendingSessionId(null);
		}
	}, [isAwaitingResponse, isStreaming]);
	useEffect(() => {
		if (!sendPending || isStreaming || isAwaitingResponse) {
			if (sendPendingTimeoutRef.current) {
				clearTimeout(sendPendingTimeoutRef.current);
				sendPendingTimeoutRef.current = null;
			}
			return;
		}
		if (!sendPendingTimeoutRef.current) {
			sendPendingTimeoutRef.current = setTimeout(() => {
				setSendPending(false);
				setSendPendingSessionId(null);
			}, 8000);
		}
		return () => {
			if (sendPendingTimeoutRef.current) {
				clearTimeout(sendPendingTimeoutRef.current);
				sendPendingTimeoutRef.current = null;
			}
		};
	}, [isAwaitingResponse, isStreaming, sendPending]);
	const [showFileMentionPopup, setShowFileMentionPopup] = useState(false);
	const [fileMentionQuery, setFileMentionQuery] = useState("");
	const [showSlashPopup, setShowSlashPopup] = useState(false);
	const [voiceMode, setVoiceMode] = useState<VoiceMode>(null);
	const [isUploading, setIsUploading] = useState(false);
	const [availableModels, setAvailableModels] = useState<PiModelInfo[]>([]);
	const [selectedModelRef, setSelectedModelRef] = useState<string | null>(null);
	const [isSwitchingModel, setIsSwitchingModel] = useState(false);
	const [modelQuery, setModelQuery] = useState("");
	const [commandError, setCommandError] = useState<Error | null>(null);
	const [customCommands, setCustomCommands] = useState<SlashCommand[]>([]);
	const [sessionTokens, setSessionTokens] = useState<{
		input: number;
		output: number;
	} | null>(null);
	const [isUserScrolled, setIsUserScrolled] = useState(
		() => getCachedScrollPosition(scrollStorageKey) !== null,
	);
	const isUserScrolledRef = useRef(isUserScrolled);
	// Set to true by wheel/touch/pointer events on the container.
	// Cleared on send and jump-to-bottom. Only while this is true does
	// the scroll event handler update isUserScrolled state.
	const userInitiatedScrollRef = useRef(false);

	const scrollToBottom = useCallback(() => {
		const c = messagesContainerRef.current;
		if (!c) return;
		c.scrollTop = c.scrollHeight;
	}, []);

	const LOAD_MORE_COUNT = 30;
	const [visibleCount, setVisibleCount] = useState(
		Math.max(messages.length, 30),
	);
	useEffect(() => {
		setVisibleCount((prev) => Math.max(prev, messages.length));
	}, [messages.length]);

	// A2UI integration - adapt Pi messages to expected format
	const a2uiMessagesRef = useRef<Array<{ info: { id: string; role: string } }>>(
		[],
	);
	// Keep ref in sync with messages
	a2uiMessagesRef.current = messages.map((m) => ({
		info: { id: m.id, role: m.role },
	}));

	const {
		surfaces: a2uiSurfaces,
		handleAction: handleA2UIAction,
		getUnanchoredSurfaces,
	} = useA2UI(a2uiMessagesRef, {
		onSurfaceReceived: useCallback(() => {
			// Auto-scroll when A2UI surface arrives
			if (!isUserScrolledRef.current) {
				scrollToBottom();
			}
		}, [scrollToBottom]),
	});

	// Memoized map of message ID to surfaces to avoid creating new arrays on each render
	// Also track "orphaned" surfaces whose anchor doesn't match any current message
	const { surfacesByMessageId, orphanedSurfaces } = useMemo(() => {
		const map = new Map<string, A2UISurfaceState[]>();
		const messageIds = new Set(messages.map((m) => m.id));
		const orphaned: A2UISurfaceState[] = [];

		for (const surface of a2uiSurfaces) {
			if (surface.anchorMessageId && messageIds.has(surface.anchorMessageId)) {
				const existing = map.get(surface.anchorMessageId) || [];
				existing.push(surface);
				map.set(surface.anchorMessageId, existing);
			} else {
				// Surface has no anchor or anchor message doesn't exist
				orphaned.push(surface);
			}
		}
		return { surfacesByMessageId: map, orphanedSurfaces: orphaned };
	}, [a2uiSurfaces, messages]);

	// Extract todos from messages and notify parent
	useEffect(() => {
		if (!onTodosChange) return;

		// Go through all messages in reverse to find the most recent todowrite
		for (let i = messages.length - 1; i >= 0; i--) {
			const msg = messages[i];
			for (let j = msg.parts.length - 1; j >= 0; j--) {
				const part = msg.parts[j];
				if (
					part.type === "tool_call" &&
					part.name?.toLowerCase().includes("todo")
				) {
					const input = part.input as Record<string, unknown> | undefined;
					if (input?.todos && Array.isArray(input.todos)) {
						onTodosChange(input.todos as TodoItem[]);
						return;
					}
				}
			}
		}
		// No todos found
		onTodosChange([]);
	}, [messages, onTodosChange]);

	// Voice configuration
	const voiceConfig = useMemo(
		() =>
			(features?.voice as unknown as import("@/lib/voice/types").VoiceConfig) ??
			null,
		[features?.voice],
	);

	const currentModelRef = useMemo(() => {
		if (!piState?.model) return null;
		return `${piState.model.provider}/${piState.model.id}`;
	}, [piState?.model]);
	const canSwitchModel = Boolean(
		piState && !piState.isStreaming && !piState.isCompacting && !isStreaming,
	);
	const currentModelInfo = useMemo(() => {
		if (piState?.model) {
			return piState.model;
		}
		if (!selectedModelRef) return null;
		return (
			availableModels.find(
				(model) => `${model.provider}/${model.id}` === selectedModelRef,
			) ?? null
		);
	}, [availableModels, piState?.model, selectedModelRef]);
	const contextWindowLimit = useMemo(() => {
		if (!currentModelInfo) return 200000;
		if (currentModelInfo.contextWindow > 0) {
			return currentModelInfo.contextWindow;
		}
		if (currentModelInfo.maxTokens > 0) {
			return currentModelInfo.maxTokens;
		}
		return 200000;
	}, [currentModelInfo]);

	const modelStorageKey = useMemo(() => {
		if (!selectedSessionId) return null;
		return `oqto:chatModel:${selectedSessionId}`;
	}, [selectedSessionId]);

	useEffect(() => {
		if (!modelStorageKey) return;
		const modelRef = currentModelRef ?? selectedModelRef;
		try {
			if (modelRef) {
				localStorage.setItem(modelStorageKey, modelRef);
			} else {
				localStorage.removeItem(modelStorageKey);
			}
		} catch {
			// Ignore storage errors.
		}
	}, [currentModelRef, modelStorageKey, selectedModelRef]);

	const displayError = commandError ?? error;
	const historyPending =
		messages.length === 0 && (piState?.messageCount ?? 0) > 0;
	const showSkeleton = messages.length === 0 && !displayError && historyPending;

	const ChatSkeleton = (
		<div className="flex-1 flex flex-col gap-4 min-h-0 animate-pulse">
			<div className="flex-1 bg-muted/20 p-4 space-y-6">
				<div className="mr-8 space-y-2">
					<div className="h-4 bg-muted/40 w-24" />
					<div className="h-16 bg-muted/30" />
				</div>
				<div className="ml-8 space-y-2">
					<div className="h-4 bg-muted/40 w-16 ml-auto" />
					<div className="h-10 bg-muted/30" />
				</div>
				<div className="mr-8 space-y-2">
					<div className="h-4 bg-muted/40 w-24" />
					<div className="h-24 bg-muted/30" />
				</div>
			</div>
			<div className="h-10 bg-muted/20" />
		</div>
	);
	// Slash query stored in ref -- updated synchronously in handleInputChange
	const slashQueryRef = useRef(parseSlashInput(inputValueRef.current));

	const enqueueMessage = useCallback(
		(rawText?: string) => {
			const trimmed = (rawText ?? inputValueRef.current).trim();
			if (!trimmed) return;

			if (fileAttachments.length > 0) {
				toast.error("Queued messages do not support file attachments yet.");
				return;
			}

			if (draftSaveTimeoutRef.current) {
				clearTimeout(draftSaveTimeoutRef.current);
				draftSaveTimeoutRef.current = null;
			}

			const isShellCommand = trimmed.startsWith("!");
			const shellCommand = isShellCommand ? trimmed.slice(1).trim() : "";
			let message = trimmed;
			if (isShellCommand && shellCommand) {
				message = `Run this shell command and show me the output:\n\`\`\`bash\n${shellCommand}\n\`\`\``;
			}

			const id =
				typeof crypto !== "undefined" && "randomUUID" in crypto
					? crypto.randomUUID()
					: `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;

			setQueuedMessages((prev) => [...prev, { id, text: message }]);
			setInput("");
			setFileAttachments([]);
			setShowSlashPopup(false);
			setCommandError(null);
			try {
				localStorage.removeItem(draftStorageKey);
			} catch {
				// Ignore localStorage errors
			}
			if (inputRef.current) {
				inputRef.current.style.height = "auto";
			}
		},
		[draftStorageKey, fileAttachments.length, setInput],
	);
	const builtInCommands = useMemo<SlashCommand[]>(() => {
		const commands: SlashCommand[] = [
			{ name: "compact", description: "Summarize context" },
			{ name: "new", description: "Start a fresh session" },
			{ name: "reset", description: "Reload personality and user files" },
			{ name: "abort", description: "Abort current run" },
			{ name: "stats", description: "Show session stats" },
			{ name: "steer", description: "Send a steering message" },
			{ name: "followup", description: "Queue a follow-up message" },
		];
		if (canSwitchModel) {
			commands.push({
				name: "model",
				description: "Switch model (provider/model)",
			});
		}
		return commands;
	}, [canSwitchModel]);
	const builtInCommandNames = useMemo(
		() => new Set(builtInCommands.map((cmd) => cmd.name)),
		[builtInCommands],
	);
	const slashCommands = useMemo<SlashCommand[]>(() => {
		const merged = [...builtInCommands];
		const seen = new Set(merged.map((cmd) => cmd.name));
		for (const cmd of customCommands) {
			if (!seen.has(cmd.name)) {
				merged.push(cmd);
				seen.add(cmd.name);
			}
		}
		return merged;
	}, [builtInCommands, customCommands]);
	const filteredModels = useMemo(() => {
		const query = modelQuery.trim();
		if (!query) return availableModels;
		return availableModels.filter((model) => {
			const fullRef = `${model.provider}/${model.id}`;
			return (
				fuzzyMatch(query, fullRef) ||
				fuzzyMatch(query, model.provider) ||
				fuzzyMatch(query, model.id) ||
				(model.name ? fuzzyMatch(query, model.name) : false)
			);
		});
	}, [availableModels, modelQuery]);
	// Calculate current context window size from message content.
	// Pi's usage fields are cumulative session totals, not current context.
	// ── Pi session stats for context gauge ──
	// Fetched once on session load, then updated from stream.message_end usage.
	const [piSessionTokens, setPiSessionTokens] = useState<{
		input: number;
		output: number;
	} | null>(null);

	// Fetch Pi session stats when the active session changes
	useEffect(() => {
		if (!selectedSessionId) {
			setPiSessionTokens(null);
			return;
		}
		let cancelled = false;
		const fetchStats = async () => {
			try {
				const stats = await getWsManager().agentGetSessionStats(
					selectedSessionId,
				);
				if (cancelled) return;
				if (stats && typeof stats === "object" && "tokens" in stats) {
					const tokens = (
						stats as { tokens?: { input?: number; output?: number } }
					).tokens;
					if (tokens) {
						setPiSessionTokens({
							input: tokens.input ?? 0,
							output: tokens.output ?? 0,
						});
					}
				}
			} catch {
				// Stats unavailable (session not running in Pi) - that's fine
			}
		};
		void fetchStats();
		return () => {
			cancelled = true;
		};
	}, [selectedSessionId]);

	// Refresh stats after compaction completes (context window changes significantly)
	const lastCompactionText = useMemo(() => {
		for (let i = messages.length - 1; i >= 0; i--) {
			for (const part of messages[i].parts) {
				if (
					part.type === "compaction" &&
					"text" in part &&
					(part as { text: string }).text !== "Compacting context..."
				) {
					return (part as { text: string }).text;
				}
			}
		}
		return null;
	}, [messages]);

	useEffect(() => {
		if (!lastCompactionText || !selectedSessionId) return;
		let cancelled = false;
		const refreshStats = async () => {
			try {
				const stats = await getWsManager().agentGetSessionStats(
					selectedSessionId,
				);
				if (cancelled) return;
				if (stats && typeof stats === "object" && "tokens" in stats) {
					const tokens = (
						stats as { tokens?: { input?: number; output?: number } }
					).tokens;
					if (tokens) {
						setPiSessionTokens({
							input: tokens.input ?? 0,
							output: tokens.output ?? 0,
						});
					}
				}
			} catch {
				// Stats unavailable
			}
		};
		void refreshStats();
		return () => {
			cancelled = true;
		};
	}, [lastCompactionText, selectedSessionId]);

	const contextTokenCount = useMemo(() => {
		// Priority 1: Real usage from the last assistant message (set during streaming)
		for (let i = messages.length - 1; i >= 0; i--) {
			const msg = messages[i];
			if (msg.role === "assistant" && msg.usage) {
				const u = msg.usage;
				const input = u.input_tokens ?? 0;
				const output = u.output_tokens ?? 0;
				if (input > 0 || output > 0) {
					return { inputTokens: input, outputTokens: output };
				}
			}
		}

		// Priority 2: Pi session stats (fetched on session load)
		if (piSessionTokens && (piSessionTokens.input > 0 || piSessionTokens.output > 0)) {
			return {
				inputTokens: piSessionTokens.input,
				outputTokens: piSessionTokens.output,
			};
		}

		// Priority 3: Fallback estimate from text content (4 chars ~ 1 token)
		let lastCompactionIndex = -1;
		for (let i = messages.length - 1; i >= 0; i--) {
			if (messages[i].parts.some((p) => p.type === "compaction")) {
				lastCompactionIndex = i;
				break;
			}
		}

		let inputTokens = 0;
		let outputTokens = 0;
		const startIndex = lastCompactionIndex >= 0 ? lastCompactionIndex + 1 : 0;

		for (let i = startIndex; i < messages.length; i++) {
			const msg = messages[i];
			for (const part of msg.parts) {
				const text =
					("text" in part ? (part as { text?: string }).text : null) ??
					("tool_input" in part
						? (part as { tool_input?: string }).tool_input
						: null) ??
					("output" in part
						? (part as { output?: string }).output
						: null) ??
					"";
				if (text) {
					const estimatedTokens = Math.ceil(text.length / 4);
					if (msg.role === "user") {
						inputTokens += estimatedTokens;
					} else {
						outputTokens += estimatedTokens;
					}
				}
			}
		}
		return { inputTokens, outputTokens };
	}, [messages, piSessionTokens]);

	const gaugeTokens = contextTokenCount;

	// Report token usage to parent when it changes
	useEffect(() => {
		if (onTokenUsageChange) {
			onTokenUsageChange({
				inputTokens: gaugeTokens.inputTokens,
				outputTokens: gaugeTokens.outputTokens,
				maxTokens: contextWindowLimit,
			});
		}
	}, [gaugeTokens, contextWindowLimit, onTokenUsageChange]);

	// Dictation hook
	const dictation = useDictation({
		config: voiceConfig,
		onTranscript: useCallback(
			(text: string) => {
				const prev = inputValueRef.current;
				setInput(prev ? `${prev} ${text}` : text);
			},
			[setInput],
		),
		vadTimeoutMs: features?.voice?.vad_timeout_ms,
		autoSendOnFinal: true,
		autoSendDelayMs: 50,
		onAutoSend: () => {
			const sendBtn = document.querySelector(
				"[data-dictation-send]",
			) as HTMLButtonElement | null;
			sendBtn?.click();
		},
	});

	useEffect(() => {
		if (selectedModelRef || !currentModelRef) return;
		setSelectedModelRef(currentModelRef);
	}, [currentModelRef, selectedModelRef]);

	useEffect(() => {
		// Only fetch models once session is active (piState available)
		if (!isConnected || !piState) return;
		const targetSessionId = selectedSessionId ?? piState.sessionId ?? null;
		if (!targetSessionId) return;
		let active = true;
		getWsManager()
			.agentGetAvailableModels(targetSessionId)
			.then((result) => {
				if (active) setAvailableModels((result as PiModelInfo[]) ?? []);
			})
			.catch(() => {
				if (active) setAvailableModels([]);
			});
		return () => {
			active = false;
		};
	}, [isConnected, piState, selectedSessionId]);

	useEffect(() => {
		// Only fetch commands once session is active (piState available)
		if (!isConnected || !piState) return;
		const targetSessionId = selectedSessionId ?? piState.sessionId ?? null;
		if (!targetSessionId) return;
		let active = true;
		const manager = getWsManager();
		manager
			.agentGetCommands(targetSessionId)
			.then((commands) => {
				if (!active) return;
				setCustomCommands(
					commands.map((cmd) => ({
						name: cmd.name,
						description: cmd.description ?? undefined,
					})),
				);
			})
			.catch(() => {
				if (active) setCustomCommands([]);
			});
		return () => {
			active = false;
		};
	}, [isConnected, piState, selectedSessionId]);

	// biome-ignore lint/correctness/useExhaustiveDependencies: contextWindowLimit is stable
	const refreshStats = useCallback(async () => {
		const targetSessionId = selectedSessionId ?? piState?.sessionId ?? null;
		if (!targetSessionId) return;
		try {
			const stats = await getWsManager().agentGetSessionStats(targetSessionId);
			console.log("[Pi stats] raw:", stats);
			const fallbackStats = sessionMeta?.stats ?? null;
			const tokens =
				stats && typeof stats === "object" && "tokens" in stats
					? (stats as { tokens?: { input?: number; output?: number } }).tokens
					: fallbackStats
						? {
								input: fallbackStats.tokens_in,
								output: fallbackStats.tokens_out,
							}
						: null;
			if (tokens) {
				console.log(
					"[Pi stats] tokens:",
					tokens,
					"contextWindow:",
					contextWindowLimit,
				);
				setSessionTokens({
					input: tokens.input ?? 0,
					output: tokens.output ?? 0,
				});
			}
		} catch {
			// Ignore stats errors
		}
	}, [piState?.sessionId, selectedSessionId, sessionMeta?.stats]);

	// biome-ignore lint/correctness/useExhaustiveDependencies: messages.length triggers refresh when message count changes
	useEffect(() => {
		if (!isConnected || isStreaming) return;
		// Small delay to ensure Pi has updated internal stats after streaming
		const timer = setTimeout(() => refreshStats(), 300);
		return () => clearTimeout(timer);
	}, [isConnected, isStreaming, messages.length, refreshStats]);

	// Discrete sessions: reset scroll state only when switching to a different session.
	const prevSessionIdRef = useRef(selectedSessionId);
	useEffect(() => {
		if (!selectedSessionId) return;
		if (selectedSessionId === prevSessionIdRef.current) return;
		prevSessionIdRef.current = selectedSessionId;
		setIsUserScrolled(false);
		isUserScrolledRef.current = false;
	}, [selectedSessionId]);

	// Scroll to message when scrollToMessageId changes (from search results)
	useEffect(() => {
		if (!scrollToMessageId || !messagesContainerRef.current) return;

		let targetId = scrollToMessageId;
		if (targetId.startsWith("line-")) {
			const idx = Number.parseInt(targetId.slice(5), 10);
			const resolved = Number.isFinite(idx) ? messages[idx - 1]?.id : undefined;
			if (resolved) targetId = resolved;
		}

		// Find the message element with this ID
		const messageEl = messagesContainerRef.current.querySelector(
			`[data-message-id="${targetId}"]`,
		);

		if (messageEl) {
			// Ensure we have enough messages visible
			const messageIndex = messages.findIndex((m) => m.id === targetId);
			if (messageIndex !== -1) {
				const messagesFromEnd = messages.length - messageIndex;
				if (messagesFromEnd > visibleCount) {
					setVisibleCount(messagesFromEnd + 10);
				}
			}

			// Scroll to the message
			requestAnimationFrame(() => {
				messageEl.scrollIntoView({ behavior: "smooth", block: "center" });
				// Add highlight animation
				messageEl.classList.add("search-highlight");
				setTimeout(() => {
					messageEl.classList.remove("search-highlight");
				}, 2000);
			});

			setIsUserScrolled(true);
			onScrollToMessageComplete?.();
		}
	}, [scrollToMessageId, messages, visibleCount, onScrollToMessageComplete]);

	// Keep ref mirror in sync with state
	useEffect(() => {
		isUserScrolledRef.current = isUserScrolled;
	}, [isUserScrolled]);

	// Auto-scroll when messages change (new message, streaming token update,
	// tool call result). Only scrolls if user hasn't manually scrolled up.
	// biome-ignore lint/correctness/useExhaustiveDependencies: setBusyForEvent is stable callback
	useEffect(() => {
		if (!initialScrollDoneRef.current) return;
		if (!isUserScrolledRef.current) {
			scrollToBottom();
		}
	}, [messages, scrollToBottom]);

	// Update isUserScrolled from real user scroll events only.
	// wheel/touch/pointer events on the container set userInitiatedScrollRef
	// so we know the following scroll event came from the user.
	useEffect(() => {
		const container = messagesContainerRef.current;
		if (!container) return;
		const mark = () => {
			userInitiatedScrollRef.current = true;
		};
		container.addEventListener("wheel", mark, { passive: true });
		container.addEventListener("touchstart", mark, { passive: true });
		container.addEventListener("pointerdown", mark, { passive: true });
		return () => {
			container.removeEventListener("wheel", mark);
			container.removeEventListener("touchstart", mark);
			container.removeEventListener("pointerdown", mark);
		};
	}, []);

	const handleScrollToBottom = useCallback(() => {
		userInitiatedScrollRef.current = false;
		setIsUserScrolled(false);
		isUserScrolledRef.current = false;
		setCachedScrollPosition(null, scrollStorageKey);
		scrollToBottom();
	}, [scrollStorageKey, scrollToBottom]);

	// Initial scroll position
	useLayoutEffect(() => {
		if (initialScrollDoneRef.current || !messagesContainerRef.current) return;
		if (messages.length === 0) return;
		initialScrollDoneRef.current = true;
		const container = messagesContainerRef.current;
		const cachedPosition = getCachedScrollPosition(scrollStorageKey);
		if (cachedPosition !== null) {
			container.scrollTop = cachedPosition;
		} else {
			messagesEndRef.current?.scrollIntoView();
		}
	}, [messages.length, scrollStorageKey]);

	const handleScroll = useCallback(() => {
		const container = messagesContainerRef.current;
		if (!container) return;

		// Load more when near top
		if (container.scrollTop < 100 && visibleCount < messages.length) {
			const prevScrollHeight = container.scrollHeight;
			setVisibleCount((prev) =>
				Math.min(prev + LOAD_MORE_COUNT, messages.length),
			);
			requestAnimationFrame(() => {
				container.scrollTop = container.scrollHeight - prevScrollHeight;
			});
		}

		// Only update scroll state when the scroll came from a user gesture
		if (!userInitiatedScrollRef.current) return;
		userInitiatedScrollRef.current = false;

		const atBottom =
			container.scrollHeight - container.scrollTop - container.clientHeight <
			80;
		setIsUserScrolled(!atBottom);
		isUserScrolledRef.current = !atBottom;
		if (atBottom) {
			setCachedScrollPosition(null, scrollStorageKey);
		} else {
			setCachedScrollPosition(container.scrollTop, scrollStorageKey);
		}
	}, [scrollStorageKey, visibleCount, messages.length]);

	// Focus input on mount - only on desktop to avoid opening keyboard on mobile
	useEffect(() => {
		// Check if device has a coarse pointer (touch) - indicates mobile
		const isTouchDevice = window.matchMedia("(pointer: coarse)").matches;
		if (!isTouchDevice) {
			inputRef.current?.focus();
		}
	}, []);

	// Auto-resize is now handled inline in handleInputChange for better performance.
	// This effect only handles dictation mode changes.
	useEffect(() => {
		if (dictation.isActive && inputRef.current) {
			inputRef.current.style.height = "36px";
		}
	}, [dictation.isActive]);

	// Handle file upload
	const handleFileUpload = useCallback(
		async (files: FileList | null) => {
			if (!files || files.length === 0) return;

			// File attachments require a workspace path to upload to
			// The path is always available for default chat, but may be loading initially
			if (!normalizedWorkspacePath) {
				toast.error(
					"Workspace path is still loading. Please try again in a moment.",
				);
				return;
			}

			setIsUploading(true);

			try {
				for (const file of Array.from(files)) {
					try {
						if (!normalizedWorkspacePath) {
							throw new Error("Workspace path is still loading");
						}
						const uploadPath = `uploads/${file.name}`;
						await uploadFileMux(normalizedWorkspacePath, uploadPath, file);

						const attachment: FileAttachment = {
							id: `file-${Date.now()}-${Math.random().toString(36).slice(2)}`,
							path: uploadPath,
							filename: file.name,
							type: "file",
						};
						setFileAttachments((prev) => [...prev, attachment]);
					} catch (err) {
						console.error("Failed to upload file:", err);
						toast.error(`Failed to upload ${file.name}`, {
							description: err instanceof Error ? err.message : "Unknown error",
						});
					}
				}
			} finally {
				setIsUploading(false);
				if (fileInputRef.current) {
					fileInputRef.current.value = "";
				}
			}
		},
		[normalizedWorkspacePath],
	);

	const handleModelChange = useCallback(
		async (value: string) => {
			if (!canSwitchModel) {
				throw new Error("Model switching is only available when Pi is idle.");
			}
			const separatorIndex = value.indexOf("/");
			if (separatorIndex <= 0 || separatorIndex === value.length - 1) return;
			const provider = value.slice(0, separatorIndex);
			const modelId = value.slice(separatorIndex + 1);
			const previousModelRef = selectedModelRef;
			setSelectedModelRef(value);
			setIsSwitchingModel(true);
			try {
				const targetSessionId = selectedSessionId ?? piState?.sessionId ?? null;
				if (!targetSessionId) {
					throw new Error("No active session");
				}
				// Use WebSocket to set model - works for both default chat and workspace
				const manager = getWsManager();
				await manager.agentSetModel(targetSessionId, provider, modelId);
				await refresh();
			} catch (err) {
				console.error("Failed to switch model:", err);
				// Revert optimistic update on failure
				setSelectedModelRef(previousModelRef);
			} finally {
				setIsSwitchingModel(false);
			}
		},
		[
			canSwitchModel,
			piState?.sessionId,
			refresh,
			selectedModelRef,
			selectedSessionId,
		],
	);

	// biome-ignore lint/correctness/useExhaustiveDependencies: messages dep intentionally omitted
	const runSlashCommand = useCallback(
		async (command: string, args: string) => {
			setCommandError(null);
			const trimmedArgs = args.trim();
			const needsArgs = ["steer", "followup", "model"].includes(command);
			if (needsArgs && !trimmedArgs) {
				setInput(`/${command} `);
				inputRef.current?.focus();
				return { handled: true, clearInput: false };
			}

			switch (command) {
				case "compact": {
					await compact(trimmedArgs || undefined);
					await refresh();
					return { handled: true, clearInput: true };
				}
				case "new": {
					await newSession();
					return { handled: true, clearInput: true };
				}
				case "reset": {
					await resetSession();
					return { handled: true, clearInput: true };
				}
				case "abort": {
					await abort();
					return { handled: true, clearInput: true };
				}
				case "stats": {
					const targetSessionId =
						selectedSessionId ?? piState?.sessionId ?? null;
					if (!targetSessionId) {
						throw new Error("No active session");
					}
					const stats =
						await getWsManager().agentGetSessionStats(targetSessionId);
					const safeStats = stats && typeof stats === "object" ? stats : null;
					const fallbackStats = sessionMeta?.stats ?? null;
					const tokens =
						safeStats && "tokens" in safeStats
							? (
									safeStats as {
										tokens?: {
											input?: number;
											output?: number;
											cache_read?: number;
											cache_write?: number;
											total?: number;
										};
									}
								).tokens
							: fallbackStats
								? {
										input: fallbackStats.tokens_in,
										output: fallbackStats.tokens_out,
										cache_read: fallbackStats.cache_read,
										cache_write: fallbackStats.cache_write,
										total:
											fallbackStats.tokens_in +
											fallbackStats.tokens_out +
											fallbackStats.cache_read +
											fallbackStats.cache_write,
									}
								: null;
					const text = [
						"Session stats",
						`- user_messages: ${
							typeof (safeStats as { user_messages?: number })
								?.user_messages === "number"
								? (safeStats as { user_messages?: number }).user_messages
								: 0
						}`,
						`- assistant_messages: ${
							typeof (safeStats as { assistant_messages?: number })
								?.assistant_messages === "number"
								? (safeStats as { assistant_messages?: number })
										.assistant_messages
								: 0
						}`,
						`- tool_calls: ${
							typeof (safeStats as { tool_calls?: number })?.tool_calls ===
							"number"
								? (safeStats as { tool_calls?: number }).tool_calls
								: 0
						}`,
						`- total_messages: ${
							typeof (safeStats as { total_messages?: number })
								?.total_messages === "number"
								? (safeStats as { total_messages?: number }).total_messages
								: 0
						}`,
						tokens
							? `- tokens: in ${tokens.input ?? 0}, out ${
									tokens.output ?? 0
								}, cache read ${tokens.cache_read ?? 0}, cache write ${
									tokens.cache_write ?? 0
								}, total ${tokens.total ?? 0}`
							: "- tokens: 0",
					].join("\n");
					appendLocalAssistantMessage(text);
					return { handled: true, clearInput: true };
				}
				case "steer": {
					await send(trimmedArgs, { mode: "steer" });
					return { handled: true, clearInput: true };
				}
				case "followup": {
					enqueueMessage(trimmedArgs);
					return { handled: true, clearInput: true };
				}
				case "model": {
					if (!canSwitchModel) {
						throw new Error(
							"Model switching is only available when Pi is idle.",
						);
					}
					const separatorIndex = trimmedArgs.indexOf("/");
					if (
						separatorIndex <= 0 ||
						separatorIndex === trimmedArgs.length - 1
					) {
						throw new Error("Model must be provider/model");
					}
					await handleModelChange(trimmedArgs);
					return { handled: true, clearInput: true };
				}
				default:
					return { handled: false, clearInput: false };
			}
		},
		[
			abort,
			appendLocalAssistantMessage,
			canSwitchModel,
			compact,
			enqueueMessage,
			handleModelChange,
			newSession,
			piState?.sessionId,
			refresh,
			resetSession,
			selectedSessionId,
			send,
			sessionMeta?.stats,
		],
	);

	const handleSend = useCallback(
		async (mode: "prompt" | "steer" | "follow_up" = "steer") => {
			const trimmed = inputValueRef.current.trim();
			if (!trimmed && fileAttachments.length === 0) return;

			const sq = slashQueryRef.current;
			if (sq.isSlash && builtInCommandNames.has(sq.command)) {
				try {
					const result = await runSlashCommand(sq.command, sq.args);
					if (result.handled) {
						if (result.clearInput) {
							setInput("");
							setFileAttachments([]);
							if (inputRef.current) {
								inputRef.current.style.height = "auto";
							}
						}
						setShowSlashPopup(false);
						return;
					}
				} catch (err) {
					setCommandError(
						err instanceof Error ? err : new Error("Command failed"),
					);
					return;
				}
			}

			if (draftSaveTimeoutRef.current) {
				clearTimeout(draftSaveTimeoutRef.current);
				draftSaveTimeoutRef.current = null;
			}

			// Check for shell command (starts with "!")
			const isShellCommand = trimmed.startsWith("!");
			const shellCommand = isShellCommand ? trimmed.slice(1).trim() : "";

			// Build message with file attachments
			let message = trimmed;
			if (isShellCommand && shellCommand) {
				// Convert shell command to a prompt for Pi's bash tool
				message = `Run this shell command and show me the output:\n\`\`\`bash\n${shellCommand}\n\`\`\``;
			} else if (fileAttachments.length > 0) {
				const fileRefs = fileAttachments.map((f) => `@${f.path}`).join(" ");
				message = `${fileRefs}\n\n${trimmed}`;
			}

			const draftInput = inputValueRef.current;
			const draftAttachments = fileAttachments;
			const hasHistory =
				messages.length > 0 || (piState?.messageCount ?? 0) > 0;
			const effectiveMode =
				mode === "follow_up" || mode === "steer"
					? hasHistory
						? mode
						: "prompt"
					: mode;

			setSendPending(true);
			const resolvedSessionId = selectedSessionId ?? null;
			if (!resolvedSessionId) {
				setSendPending(false);
				toast.error("No active chat session.");
				return;
			}

			setInput("");
			setFileAttachments([]);
			// Clear draft from localStorage
			try {
				localStorage.removeItem(draftStorageKey);
			} catch {
				// Ignore localStorage errors
			}
			// Reset textarea height
			if (inputRef.current) {
				inputRef.current.style.height = "auto";
			}

			userInitiatedScrollRef.current = false;
			setIsUserScrolled(false);
			isUserScrolledRef.current = false;

			setSendPendingSessionId(resolvedSessionId);
			try {
				await send(message, {
					mode: effectiveMode,
					sessionId: resolvedSessionId,
				});
				// Notify that a message was sent (for sidebar refresh)
				onMessageSent?.();
			} catch {
				setSendPending(false);
				setSendPendingSessionId(null);
				setInput(draftInput);
				setFileAttachments(draftAttachments);
				toast.error("Failed to send message.");
			}
		},
		[
			builtInCommandNames,
			draftStorageKey,
			fileAttachments,
			messages.length,
			onMessageSent,
			piState?.messageCount,
			runSlashCommand,
			selectedSessionId,
			send,
			setInput,
		],
	);

	const handleQueueIntent = useCallback(() => {
		const sq = slashQueryRef.current;
		if (sq.isSlash && builtInCommandNames.has(sq.command)) {
			handleSend("steer");
			return;
		}
		enqueueMessage();
	}, [builtInCommandNames, enqueueMessage, handleSend]);

	const messagesRef = useRef(messages);
	messagesRef.current = messages;
	const piStateRef = useRef(piState);
	piStateRef.current = piState;
	useEffect(() => {
		if (queuedMessages.length === 0) return;
		if (isStreaming || isAwaitingResponse) return;
		if (queueSendInFlightRef.current) return;

		const now = Date.now();
		if (queueCooldownRef.current && now - queueCooldownRef.current < 2000) {
			return;
		}

		const next = queuedMessages[0];
		if (!next?.text) return;

		queueSendInFlightRef.current = true;
		(async () => {
			setSendPending(true);
			const resolvedSessionId = selectedSessionId ?? null;
			if (!resolvedSessionId) {
				setSendPending(false);
				toast.error("No active chat session.");
				return;
			}
			setSendPendingSessionId(resolvedSessionId);
			const hasHistory =
				messagesRef.current.length > 0 ||
				(piStateRef.current?.messageCount ?? 0) > 0;
			const queueMode = hasHistory ? "follow_up" : "prompt";
			send(next.text, { mode: queueMode, sessionId: resolvedSessionId })
				.then(() => {
					setQueuedMessages((prev) => prev.slice(1));
					onMessageSent?.();
				})
				.catch(() => {
					queueCooldownRef.current = Date.now();
					setSendPending(false);
					setSendPendingSessionId(null);
					toast.error("Failed to send queued message.");
				})
				.finally(() => {
					queueSendInFlightRef.current = false;
				});
		})().catch(() => {
			queueSendInFlightRef.current = false;
			setSendPending(false);
			setSendPendingSessionId(null);
			toast.error("Failed to send queued message.");
		});
	}, [
		isAwaitingResponse,
		isStreaming,
		onMessageSent,
		queuedMessages,
		selectedSessionId,
		send,
	]);

	const handleQueueEdit = useCallback((id: string, text: string) => {
		setQueuedMessages((prev) =>
			prev.map((item) => (item.id === id ? { ...item, text } : item)),
		);
	}, []);

	const handleQueueRemove = useCallback((id: string) => {
		setQueuedMessages((prev) => prev.filter((item) => item.id !== id));
	}, []);

	const handleQueueMove = useCallback((id: string, direction: -1 | 1) => {
		setQueuedMessages((prev) => {
			const index = prev.findIndex((item) => item.id === id);
			if (index < 0) return prev;
			const targetIndex = index + direction;
			if (targetIndex < 0 || targetIndex >= prev.length) return prev;
			const next = [...prev];
			const [item] = next.splice(index, 1);
			next.splice(targetIndex, 0, item);
			return next;
		});
	}, []);

	const handleQueueClear = useCallback(() => {
		setQueuedMessages([]);
	}, []);

	const handleKeyDown = useCallback(
		(e: KeyboardEvent<HTMLTextAreaElement>) => {
			const sq = slashQueryRef.current;
			if (showSlashPopup && sq.isSlash && !sq.args) {
				if (
					["ArrowDown", "ArrowUp", "Enter", "Tab", "Escape"].includes(e.key)
				) {
					return;
				}
			}
			// Let file mention popup handle its keys
			if (showFileMentionPopup) {
				if (
					["ArrowDown", "ArrowUp", "Enter", "Tab", "Escape"].includes(e.key)
				) {
					return;
				}
			}
			if (e.key === "Enter" && !e.shiftKey) {
				e.preventDefault();
				// Steer on Enter, queue on Ctrl/Cmd+Enter
				if (e.ctrlKey || e.metaKey) {
					handleQueueIntent();
				} else {
					handleSend("steer");
				}
			}
			if (e.key === "Escape") {
				setShowFileMentionPopup(false);
				setShowSlashPopup(false);
			}
		},
		[handleQueueIntent, handleSend, showFileMentionPopup, showSlashPopup],
	);

	const handleInputChange = useCallback(
		(e: ChangeEvent<HTMLTextAreaElement>) => {
			const textarea = e.target;
			const value = textarea.value;

			// Update ref and slash query synchronously -- no React renders
			inputValueRef.current = value;
			slashQueryRef.current = parseSlashInput(value);
			setCommandError(null);

			// Keep textarea stable during dictation to avoid reflow storms.
			if (dictation.isActive) {
				textarea.style.height = "36px";
			} else {
				// Auto-resize textarea immediately
				textarea.style.height = "auto";
				textarea.style.height = `${Math.min(textarea.scrollHeight, 200)}px`;
			}

			// Debounce draft persistence to localStorage (300ms)
			if (draftSaveTimeoutRef.current) {
				clearTimeout(draftSaveTimeoutRef.current);
			}
			draftSaveTimeoutRef.current = setTimeout(() => {
				try {
					if (value.trim()) {
						localStorage.setItem(draftStorageKey, value);
					} else {
						localStorage.removeItem(draftStorageKey);
					}
				} catch {
					// Ignore localStorage errors
				}
			}, 300);

			// Defer all React state updates to avoid blocking typing
			requestAnimationFrame(() => {
				startTransition(() => {
					setCanSendInput(!!value.trim());

					if (value.startsWith("/")) {
						setShowSlashPopup(true);
						setShowFileMentionPopup(false);
						setFileMentionQuery("");
						return;
					}

					setShowSlashPopup(false);

					// Show file mention popup when typing @
					const atMatch = value.match(/@[^\s]*$/);
					if (atMatch) {
						setShowFileMentionPopup(true);
						setFileMentionQuery(atMatch[1]);
					} else {
						setShowFileMentionPopup(false);
						setFileMentionQuery("");
					}
				});
			});
		},
		[draftStorageKey, dictation.isActive],
	);

	const longPressTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);
	const suppressClickRef = useRef(false);

	const clearLongPress = useCallback(() => {
		if (longPressTimerRef.current) {
			clearTimeout(longPressTimerRef.current);
			longPressTimerRef.current = null;
		}
	}, []);

	const handleSendClick = useCallback(() => {
		if (suppressClickRef.current) {
			suppressClickRef.current = false;
			return;
		}
		handleSend("steer");
	}, [handleSend]);

	const handleSendPointerDown = useCallback(
		(e: React.PointerEvent<HTMLButtonElement>) => {
			if (e.pointerType !== "touch") return;
			clearLongPress();
			longPressTimerRef.current = setTimeout(() => {
				suppressClickRef.current = true;
				handleQueueIntent();
			}, 450);
		},
		[clearLongPress, handleQueueIntent],
	);

	const handleSendPointerUp = useCallback(() => {
		clearLongPress();
	}, [clearLongPress]);

	const handleSendPointerLeave = useCallback(() => {
		clearLongPress();
	}, [clearLongPress]);

	const handleFileSelect = useCallback(
		(file: FileAttachment) => {
			setFileAttachments((prev) => [...prev, file]);
			// Remove the @query from input
			const newValue = inputValueRef.current.replace(/@[^\s]*$/, "");
			setInput(newValue);
			setShowFileMentionPopup(false);
			setFileMentionQuery("");
			inputRef.current?.focus();
		},
		[setInput],
	);

	const handleStop = useCallback(async () => {
		await abort();
	}, [abort]);

	// Voice mode handlers
	const handleVoiceConversation = useCallback(() => {
		setVoiceMode("conversation");
		dictation.start();
	}, [dictation]);

	const handleVoiceDictation = useCallback(async () => {
		setVoiceMode("dictation");
		await dictation.start();
	}, [dictation]);

	const handleVoiceStop = useCallback(() => {
		// Use cancel() to stop without auto-send - user clicked X
		dictation.cancel();
		setVoiceMode(null);
	}, [dictation]);

	const hasVoice = !!features?.voice;
	const { t } = useTranslation();

	const tempId = sessionMeta ? getTempIdFromSession(sessionMeta) : null;
	const tempIdLabel = formatTempId(tempId);
	const formattedDate = sessionMeta?.updated_at
		? formatSessionDate(sessionMeta.updated_at)
		: sessionMeta?.created_at
			? formatSessionDate(sessionMeta.created_at)
			: null;

	const sessionTitle = (() => {
		if (sessionMeta?.title?.trim()) {
			return getDisplayPiTitle(sessionMeta);
		}
		return assistantName?.trim() || t("chat.title");
	})();

	const modelLabel = currentModelInfo
		? currentModelInfo.name?.trim() ||
			`${currentModelInfo.provider}/${currentModelInfo.id}`
		: (currentModelRef ?? selectedModelRef ?? null);
	const isWorking = isStreaming || isAwaitingResponse;
	const statusLabel = isWorking
		? t("chat.working_label")
		: t("chat.idle_label");

	const SessionHeader = (
		<div className="pb-3 mb-3 border-b border-border pr-10">
			<div className="flex items-center justify-between">
				<div className="flex items-center gap-3 min-w-0 flex-1">
					<div className="min-w-0 flex-1">
						<div className="flex items-center gap-2">
							<h1 className="text-base sm:text-lg font-semibold text-foreground tracking-wider truncate">
								{sessionTitle}
							</h1>
							{assistantName && assistantName !== sessionTitle && (
								<span className="text-xs px-1.5 py-0.5 rounded-full text-white flex-shrink-0 bg-primary/70">
									{assistantName}
								</span>
							)}
						</div>
						<div className="flex items-center gap-2 text-xs text-foreground/60 dark:text-muted-foreground">
							{(workspacePath || tempIdLabel) && (
								<span className="font-mono truncate">
									{workspacePath?.split("/").pop()}
									{tempIdLabel && ` [${tempIdLabel}]`}
								</span>
							)}
							{(workspacePath || tempIdLabel) && formattedDate && (
								<span className="opacity-50">|</span>
							)}
							{formattedDate && (
								<span className="flex-shrink-0">{formattedDate}</span>
							)}
							{(modelLabel || statusLabel) &&
								(workspacePath || tempIdLabel || formattedDate) && (
									<span className="opacity-50">|</span>
								)}
							{modelLabel && <span className="truncate">{modelLabel}</span>}
							{modelLabel && statusLabel && (
								<span className="opacity-50">|</span>
							)}
							{statusLabel && (
								<span className="flex-shrink-0">{statusLabel}</span>
							)}
						</div>
					</div>
				</div>
			</div>
			<div className="mt-2">
				<ContextWindowGauge
					inputTokens={gaugeTokens.inputTokens}
					outputTokens={gaugeTokens.outputTokens}
					maxTokens={contextWindowLimit}
					locale={locale}
					compact
				/>
			</div>
		</div>
	);

	return (
		<div className={cn("flex flex-col h-full min-h-0", className)}>
			{!hideHeader && SessionHeader}

			{/* Error banner - only show if no cached messages available */}
			{displayError && messages.length === 0 && (
				<div className="px-4 py-2 bg-destructive/10 text-destructive text-sm">
					{displayError.message}
				</div>
			)}

			{/* Messages area */}
			<div className="relative flex-1 min-h-0">
				<div
					ref={messagesContainerRef}
					onScroll={handleScroll}
					className="h-full bg-muted/30 border border-border p-2 sm:p-4 overflow-y-auto scrollbar-hide"
					data-spotlight="chat-timeline"
				>
					<div>
						{showSkeleton && ChatSkeleton}

						{!showSkeleton &&
							messages.length === 0 &&
							!sendPending &&
							!isStreaming &&
							!isAwaitingResponse && (
								<div className="flex items-center gap-2 text-sm text-muted-foreground">
									<span>{t("chat.noMessages")}</span>
								</div>
							)}

						{/* Load more indicator */}
						{messages.length > visibleCount && (
							<div className="text-center text-xs text-muted-foreground py-2">
								{messages.length - visibleCount} older messages...
							</div>
						)}

						{/* Only render the last visibleCount messages for performance */}
						{!showSkeleton &&
							(() => {
								const visibleMessages = messages.slice(-visibleCount);
								const grouped = groupMessages(visibleMessages);
								const lastGroup = grouped[grouped.length - 1];
								const activeSessionKey = selectedSessionId ?? null;
								const isWorking =
									isStreaming ||
									isAwaitingResponse ||
									(sendPending &&
										!!sendPendingSessionId &&
										sendPendingSessionId === activeSessionKey);
								const needsPendingAssistant =
									isWorking && (!lastGroup || lastGroup.role === "user");
								const groupsToRender = needsPendingAssistant
									? [
											...grouped,
											{
												role: "assistant" as const,
												messages: [
													{
														id: "pending-assistant",
														role: "assistant" as const,
														parts: [],
														timestamp: Date.now(),
														isStreaming: true,
													},
												],
											},
										]
									: grouped;

								return groupsToRender.map((group, groupIndex) => {
									const groupSurfaces = group.messages.flatMap(
										(m) => surfacesByMessageId.get(m.id) ?? [],
									);
									const groupMessageId = group.messages[0]?.id;
									// Check if this is the last assistant group
									const isLastAssistantGroup =
										group.role === "assistant" &&
										!groupsToRender
											.slice(groupIndex + 1)
											.some((g) => g.role === "assistant");

									// Detect model change: compare this assistant group's model
									// to the previous assistant group's model
									let modelChangeDivider: React.ReactNode = null;
									if (group.role === "assistant") {
										const thisModel = getGroupModelRef(group);
										if (thisModel) {
											// Find previous assistant group
											for (let i = groupIndex - 1; i >= 0; i--) {
												if (groupsToRender[i].role === "assistant") {
													const prevModel = getGroupModelRef(groupsToRender[i]);
													if (prevModel && prevModel !== thisModel) {
														modelChangeDivider = (
															<ModelChangeDivider modelRef={thisModel} />
														);
													}
													break;
												}
											}
										}
									}

									return (
										<div
											key={`${groupMessageId ?? `${group.role}-${groupIndex}`}-${groupIndex}`}
											className={groupIndex > 0 ? "mt-4 sm:mt-6" : ""}
										>
											{modelChangeDivider}
											<MessageGroupCard
												group={group}
												assistantName={assistantName}
												tempIdLabel={tempIdLabel}
												workspacePath={workspacePath}
												locale={locale}
												a2uiSurfaces={groupSurfaces}
												onA2UIAction={handleA2UIAction}
												messageId={groupMessageId}
												showWorkingIndicator={isWorking && isLastAssistantGroup}
											/>
										</div>
									);
								});
							})()}

						{/* Orphaned A2UI surfaces (no valid anchor) */}
						{orphanedSurfaces.length > 0 && (
							<div className="space-y-2 mt-4">
								{orphanedSurfaces.map((surface) => (
									<A2UICallCard
										key={surface.surfaceId}
										surfaceId={surface.surfaceId}
										messages={surface.messages}
										blocking={surface.blocking}
										requestId={surface.requestId}
										answered={surface.answered}
										answeredAction={surface.answeredAction}
										answeredAt={surface.answeredAt}
										onAction={handleA2UIAction}
									/>
								))}
							</div>
						)}
					</div>
					<div ref={messagesEndRef} />
				</div>

				{/* Jump to bottom button - appears when user has scrolled up */}
				{isUserScrolled && (
					<button
						type="button"
						onClick={handleScrollToBottom}
						className="absolute bottom-3 left-1/2 -translate-x-1/2 z-10 flex items-center gap-1.5 px-3 py-1.5 rounded-full bg-primary text-primary-foreground text-xs shadow-md hover:bg-primary/90 transition-colors"
						title="Jump to bottom"
					>
						<svg
							xmlns="http://www.w3.org/2000/svg"
							width="12"
							height="12"
							viewBox="0 0 24 24"
							fill="none"
							stroke="currentColor"
							strokeWidth="2"
							strokeLinecap="round"
							strokeLinejoin="round"
							aria-hidden="true"
						>
							<polyline points="6 9 12 15 18 9" />
						</svg>
						Jump to bottom
					</button>
				)}
			</div>

			{/* Hidden file input */}
			<input
				ref={fileInputRef}
				type="file"
				multiple
				className="hidden"
				onChange={(e) => handleFileUpload(e.target.files)}
			/>

			{/* Chat input - canonical chat input */}
			<div className="chat-input-container flex flex-col gap-1 bg-muted/30 border border-border px-2 py-1 mt-2">
				<div className="flex items-center gap-2">
					{/* File upload button */}
					<button
						type="button"
						onClick={() => fileInputRef.current?.click()}
						disabled={isUploading}
						className="flex-shrink-0 h-8 px-2 flex items-center justify-center text-muted-foreground hover:text-foreground disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
						title={t("chat.uploadFile")}
					>
						{isUploading ? (
							<Loader2 className="size-4 animate-spin" />
						) : (
							<Paperclip className="size-4" />
						)}
					</button>

					{/* Voice menu button */}
					{hasVoice && (
						<VoiceMenuButton
							activeMode={voiceMode}
							voiceState={dictation.isActive ? "listening" : "idle"}
							onConversation={handleVoiceConversation}
							onDictation={handleVoiceDictation}
							onStop={handleVoiceStop}
							locale={locale}
							className="flex-shrink-0"
						/>
					)}

					{/* Textarea wrapper with slash command popup */}
					<div
						className="flex-1 relative flex flex-col min-h-[32px]"
						data-spotlight="chat-input"
					>
						<SlashCommandPopup
							commands={slashCommands}
							query={slashQueryRef.current.command}
							isOpen={
								showSlashPopup &&
								slashQueryRef.current.isSlash &&
								!slashQueryRef.current.args
							}
							onSelect={(cmd) => {
								const sq = slashQueryRef.current;
								if (builtInCommandNames.has(cmd.name)) {
									runSlashCommand(cmd.name, sq.args)
										.then((result) => {
											if (result.clearInput) {
												setInput("");
												setFileAttachments([]);
												if (inputRef.current) {
													inputRef.current.style.height = "auto";
												}
											}
											setShowSlashPopup(false);
										})
										.catch((err) => {
											setCommandError(
												err instanceof Error
													? err
													: new Error("Command failed"),
											);
											setShowSlashPopup(false);
										});
									return;
								}

								if (sq.args.trim()) {
									send(`/${cmd.name} ${sq.args.trim()}`)
										.then(() => {
											setInput("");
											setFileAttachments([]);
											if (inputRef.current) {
												inputRef.current.style.height = "auto";
											}
											setShowSlashPopup(false);
										})
										.catch((err) => {
											setCommandError(
												err instanceof Error
													? err
													: new Error("Command failed"),
											);
											setShowSlashPopup(false);
										});
								} else {
									setInput(`/${cmd.name} `);
									inputRef.current?.focus();
									setShowSlashPopup(false);
								}
							}}
							onClose={() => setShowSlashPopup(false)}
						/>
						<FileMentionPopup
							query={fileMentionQuery}
							isOpen={showFileMentionPopup}
							workspacePath={workspacePath ?? null}
							onSelect={handleFileSelect}
							onClose={() => {
								setShowFileMentionPopup(false);
								setFileMentionQuery("");
							}}
						/>

						{queuedMessages.length > 0 && (
							<div className="mb-2 rounded-md border border-border/60 bg-muted/20 p-2">
								<div className="flex items-center justify-between text-xs text-muted-foreground mb-2">
									<span>Queued messages</span>
									<Button
										type="button"
										variant="ghost"
										size="sm"
										className="h-6 px-2 text-xs text-muted-foreground hover:text-foreground"
										onClick={handleQueueClear}
									>
										Clear
									</Button>
								</div>
								<div className="space-y-1 max-h-32 overflow-y-auto pr-1">
									{queuedMessages.map((item, index) => (
										<div
											key={item.id}
											className="flex items-start gap-2 rounded-md bg-muted/30 p-1.5"
										>
											<span className="mt-1 text-[10px] text-muted-foreground w-4 text-right">
												{index + 1}
											</span>
											<textarea
												value={item.text}
												onChange={(e) =>
													handleQueueEdit(item.id, e.target.value)
												}
												onInput={(e) => {
													const el = e.currentTarget;
													el.style.height = "auto";
													el.style.height = `${Math.min(el.scrollHeight, 120)}px`;
												}}
												rows={1}
												className="flex-1 bg-transparent text-xs leading-4 resize-none outline-none"
											/>
											<div className="flex flex-col gap-1">
												<Button
													type="button"
													variant="ghost"
													size="icon"
													className="h-6 w-6 text-muted-foreground hover:text-foreground"
													disabled={index === 0}
													onClick={() => handleQueueMove(item.id, -1)}
												>
													<ArrowUp className="h-3 w-3" />
												</Button>
												<Button
													type="button"
													variant="ghost"
													size="icon"
													className="h-6 w-6 text-muted-foreground hover:text-foreground"
													disabled={index === queuedMessages.length - 1}
													onClick={() => handleQueueMove(item.id, 1)}
												>
													<ArrowDown className="h-3 w-3" />
												</Button>
												<Button
													type="button"
													variant="ghost"
													size="icon"
													className="h-6 w-6 text-muted-foreground hover:text-foreground"
													onClick={() => handleQueueRemove(item.id)}
												>
													<Trash2 className="h-3 w-3" />
												</Button>
											</div>
										</div>
									))}
								</div>
							</div>
						)}

						{/* File attachment chips */}
						{fileAttachments.length > 0 && (
							<div className="flex flex-wrap gap-1 mb-1">
								{fileAttachments.map((attachment) => (
									<FileAttachmentChip
										key={attachment.id}
										attachment={attachment}
										onRemove={() => {
											setFileAttachments((prev) =>
												prev.filter((a) => a.id !== attachment.id),
											);
										}}
									/>
								))}
							</div>
						)}

						{hasVoice && dictation.isActive ? (
							<DictationOverlay
								open
								value={inputValueRef.current}
								liveTranscript={dictation.liveTranscript}
								placeholder={t("chat.speakNow")}
								vadProgress={dictation.vadProgress}
								autoSend={dictation.autoSendEnabled}
								onAutoSendChange={dictation.setAutoSendEnabled}
								onStop={handleVoiceStop}
								onChange={handleInputChange}
								onKeyDown={handleKeyDown}
								onPaste={(e) => {
									// Handle pasted files
									const items = e.clipboardData?.items;
									if (!items) return;

									const files: File[] = [];
									let imageIndex = 0;
									for (const item of Array.from(items)) {
										if (item.kind === "file") {
											const file = item.getAsFile();
											if (file) {
												// Rename generic clipboard image names to be unique
												const isGenericName =
													/^image\.(png|gif|jpg|jpeg|webp)$/i.test(file.name);
												if (isGenericName) {
													const ext = file.name.split(".").pop() || "png";
													const uniqueName = `pasted-image-${Date.now()}-${imageIndex++}.${ext}`;
													const renamedFile = new File([file], uniqueName, {
														type: file.type,
													});
													files.push(renamedFile);
												} else {
													files.push(file);
												}
											}
										}
									}

									if (files.length > 0) {
										e.preventDefault();
										const dataTransfer = new DataTransfer();
										for (const file of files) {
											dataTransfer.items.add(file);
										}
										handleFileUpload(dataTransfer.files);
									}
								}}
								onFocus={(e) => {
									// Scroll input into view on mobile when keyboard opens
									setTimeout(() => {
										e.target.scrollIntoView({
											behavior: "smooth",
											block: "nearest",
										});
									}, 300);
								}}
							/>
						) : (
							<textarea
								ref={inputRef}
								autoComplete="off"
								autoCorrect="off"
								autoCapitalize="sentences"
								spellCheck={false}
								enterKeyHint="send"
								data-form-type="other"
								placeholder={t("chat.placeholder")}
								defaultValue={inputInitialValue}
								onChange={handleInputChange}
								onKeyDown={handleKeyDown}
								onPaste={(e) => {
									// Handle pasted files
									const items = e.clipboardData?.items;
									if (!items) return;

									const files: File[] = [];
									let imageIndex = 0;
									for (const item of Array.from(items)) {
										if (item.kind === "file") {
											const file = item.getAsFile();
											if (file) {
												// Rename generic clipboard image names to be unique
												const isGenericName =
													/^image\.(png|gif|jpg|jpeg|webp)$/i.test(file.name);
												if (isGenericName) {
													const ext = file.name.split(".").pop() || "png";
													const uniqueName = `pasted-image-${Date.now()}-${imageIndex++}.${ext}`;
													const renamedFile = new File([file], uniqueName, {
														type: file.type,
													});
													files.push(renamedFile);
												} else {
													files.push(file);
												}
											}
										}
									}

									if (files.length > 0) {
										e.preventDefault();
										const dataTransfer = new DataTransfer();
										for (const file of files) {
											dataTransfer.items.add(file);
										}
										handleFileUpload(dataTransfer.files);
									}
								}}
								onFocus={(e) => {
									// Scroll input into view on mobile when keyboard opens
									setTimeout(() => {
										e.target.scrollIntoView({
											behavior: "smooth",
											block: "nearest",
										});
									}, 300);
								}}
								rows={1}
								className="w-full bg-transparent border-none outline-none text-foreground placeholder:text-muted-foreground text-sm resize-none py-1.5 leading-5 max-h-[200px] overflow-y-auto"
							/>
						)}
					</div>

					{/* Stop button - only shown when streaming */}
					{isStreaming && (
						<Button
							type="button"
							onClick={handleStop}
							className="stop-button-animated flex-shrink-0 h-8 px-2 flex items-center justify-center text-destructive hover:text-destructive/80 transition-colors bg-transparent hover:bg-transparent"
							variant="ghost"
							size="icon"
							title={t("chat.stopAgent")}
						>
							<span className="stop-button-ring" aria-hidden>
								<svg viewBox="0 0 100 100" role="presentation">
									<circle
										cx="50"
										cy="50"
										r="46"
										fill="none"
										stroke="currentColor"
										strokeWidth="3"
										strokeLinecap="round"
										strokeDasharray="72 216"
										opacity="0.8"
									/>
								</svg>
							</span>
							<StopCircle className="w-4 h-4" />
						</Button>
					)}

					{/* Send button */}
					<Button
						type="button"
						data-dictation-send
						onClick={handleSendClick}
						onPointerDown={handleSendPointerDown}
						onPointerUp={handleSendPointerUp}
						onPointerCancel={handleSendPointerUp}
						onPointerLeave={handleSendPointerLeave}
						disabled={!canSendInput && fileAttachments.length === 0}
						className="flex-shrink-0 h-8 px-2 flex items-center justify-center text-muted-foreground hover:text-foreground disabled:opacity-50 disabled:cursor-not-allowed transition-colors bg-transparent hover:bg-transparent"
						variant="ghost"
						size="icon"
					>
						<Send className="w-4 h-4" />
					</Button>
				</div>
			</div>
		</div>
	);
}

// ============================================================================
// Model change divider
// ============================================================================

/** Extract a model identifier from the first assistant message in a group that has model info.
 * hstry stores model as "provider/model" or just "model"; live messages have separate fields. */
function getGroupModelRef(group: { messages: DisplayMessage[] }):
	| string
	| null {
	for (const msg of group.messages) {
		if (msg.model) {
			// If provider is separate, combine them
			if (msg.provider) return `${msg.provider}/${msg.model}`;
			// hstry may already store "provider/model" in the model field
			return msg.model;
		}
	}
	return null;
}

/** Small inline divider shown when the model changes between assistant responses. */
function ModelChangeDivider({ modelRef }: { modelRef: string }) {
	// Show a short version of the model name
	const parts = modelRef.split("/");
	const display = parts.length >= 2 ? parts.slice(1).join("/") : modelRef;
	return (
		<div className="flex items-center gap-2 py-1 mb-2">
			<div className="flex-1 border-t border-border/40" />
			<span className="text-[10px] text-muted-foreground/60 font-mono">
				switched to {display}
			</span>
			<div className="flex-1 border-t border-border/40" />
		</div>
	);
}

// ============================================================================
// Message grouping
// ============================================================================

type MessageGroup = {
	role: DisplayMessage["role"];
	messages: DisplayMessage[];
};

function groupMessages(messages: DisplayMessage[]): MessageGroup[] {
	const groups: MessageGroup[] = [];
	let current: MessageGroup | null = null;

	for (const message of messages) {
		// Skip user messages that have no renderable text content.
		// These are empty steer echoes persisted to hstry — the real
		// content lives in the optimistic message that was already shown.
		if (message.role === "user") {
			const hasText = message.parts.some(
				(p) =>
					p.type === "text" &&
					typeof (p as { text?: string }).text === "string" &&
					(p as { text: string }).text.trim().length > 0,
			);
			if (!hasText) continue;
		}

		// Tool messages are always grouped with the preceding assistant message.
		// This ensures tool_results are in the same group as their tool_calls
		// so the segment builder can match them up.
		if (message.role === "tool" && current?.role === "assistant") {
			current.messages.push(message);
			continue;
		}

		if (!current || current.role !== message.role) {
			current = { role: message.role, messages: [message] };
			groups.push(current);
			continue;
		}
		current.messages.push(message);
	}

	return groups;
}

// Compact copy button for message headers
function CompactCopyButton({
	text,
	className,
}: { text: string; className?: string }) {
	const [copied, setCopied] = useState(false);

	const handleCopy = useCallback(() => {
		try {
			if (navigator.clipboard?.writeText) {
				navigator.clipboard.writeText(text);
			} else {
				const textArea = document.createElement("textarea");
				textArea.value = text;
				textArea.style.position = "fixed";
				textArea.style.left = "-9999px";
				document.body.appendChild(textArea);
				textArea.select();
				document.execCommand("copy");
				document.body.removeChild(textArea);
			}
			setCopied(true);
			setTimeout(() => setCopied(false), 2000);
		} catch {}
	}, [text]);

	return (
		<button
			type="button"
			onClick={handleCopy}
			className={cn("text-muted-foreground hover:text-foreground", className)}
		>
			{copied ? (
				<Check className="w-3 h-3 text-primary" />
			) : (
				<Copy className="w-3 h-3" />
			)}
		</button>
	);
}

type Segment =
	| { key: string; type: "text"; text: string; timestamp: number }
	| {
			key: string;
			type: "tool_call";
			part: Extract<DisplayPart, { type: "tool_call" }>;
			toolResult?: Extract<DisplayPart, { type: "tool_result" }>;
			timestamp: number;
	  }
	| {
			key: string;
			type: "tool_result_only";
			part: Extract<DisplayPart, { type: "tool_result" }>;
			timestamp: number;
	  }
	| { key: string; type: "thinking"; text: string; timestamp: number }
	| { key: string; type: "compaction"; text: string; timestamp: number }
	| { key: string; type: "error"; text: string; timestamp: number }
	| {
			key: string;
			type: "a2ui";
			surface: A2UISurfaceState;
			timestamp: number;
	  };

const MessageGroupCard = memo(function MessageGroupCard({
	group,
	assistantName,
	tempIdLabel,
	workspacePath,
	locale = "en",
	a2uiSurfaces = [],
	onA2UIAction,
	messageId,
	showWorkingIndicator = false,
}: {
	group: MessageGroup;
	assistantName?: string | null;
	tempIdLabel?: string | null;
	workspacePath?: string | null;
	locale?: "de" | "en";
	a2uiSurfaces?: A2UISurfaceState[];
	onA2UIAction?: (action: import("@/lib/a2ui/types").A2UIUserAction) => void;
	messageId?: string;
	showWorkingIndicator?: boolean;
}) {
	const isUser = group.role === "user";
	const { t } = useTranslation();
	const { verbosity } = useChatVerbosity();
	const createdAt = group.messages[0]?.timestamp
		? new Date(group.messages[0].timestamp)
		: null;

	// Flatten parts in order, preserve message-array ordering.
	// The primary sort key is the message index (msgIndex), NOT the wall-clock
	// timestamp.  Timestamps from hstry (created_at) can be non-monotonic when
	// messages are persisted out of chronological order (e.g. batched writes).
	// Using them as a sort key reorders messages incorrectly.
	type TimedPart = {
		key: string;
		part: DisplayPart;
		/** Sort order: msgIndex * 1e6 + partIndex preserves array order. */
		timestamp: number;
	};

	const timedParts: TimedPart[] = [];
	for (const [msgIndex, message] of group.messages.entries()) {
		for (const [partIndex, part] of message.parts.entries()) {
			timedParts.push({
				key: `${message.id}-${msgIndex}-${part.type}-${partIndex}`,
				part,
				timestamp: msgIndex * 1_000_000 + partIndex,
			});
		}
	}

	const toolResults = new Map<
		string,
		Extract<DisplayPart, { type: "tool_result" }>
	>();
	// Also index by name for fallback matching when IDs don't align
	const toolResultsByName = new Map<
		string,
		Extract<DisplayPart, { type: "tool_result" }>
	>();
	const toolCallIds = new Set<string>();
	for (const { part } of timedParts) {
		if (part.type === "tool_result") {
			toolResults.set(part.toolCallId, part);
			// Index by name for fallback matching
			if (part.name) {
				toolResultsByName.set(part.name, part);
			}
		}
		if (part.type === "tool_call") {
			toolCallIds.add(part.toolCallId);
		}
	}

	const segments: Segment[] = [];
	let textBuf: string[] = [];
	let textKey: string | null = null;
	let lastTs = 0;
	const flushText = () => {
		if (textBuf.length === 0) return;
		segments.push({
			key: textKey ?? `text-${segments.length}`,
			type: "text",
			text: textBuf.join("\n\n"),
			timestamp: lastTs,
		});
		textBuf = [];
		textKey = null;
	};

	for (const { key, part, timestamp } of timedParts) {
		lastTs = timestamp;
		if (part.type === "text") {
			// Safely resolve text content (might be .text or .content depending on source)
			const partText =
				(part as { text?: string; content?: string }).text ??
				(part as { content?: string }).content ??
				"";
			// Skip empty chunks to avoid flicker
			if (!partText.trim()) continue;
			// Skip text that looks like raw tool JSON output
			const trimmedText = partText.trim();
			// Skip question tool JSON
			const looksLikeQuestionJson =
				trimmedText.startsWith("{") &&
				trimmedText.includes('"questions"') &&
				trimmedText.includes('"header"') &&
				trimmedText.includes('"options"');
			if (looksLikeQuestionJson) continue;
			// Skip raw command JSON like {"command":"ls -la"} or {"filePath":"..."}
			const looksLikeCommandJson =
				trimmedText.startsWith("{") &&
				trimmedText.endsWith("}") &&
				(trimmedText.includes('"command"') ||
					trimmedText.includes('"filePath"') ||
					trimmedText.includes('"pattern"') ||
					trimmedText.includes('"content"'));
			if (looksLikeCommandJson && trimmedText.length < 500) continue;
			if (!textKey) textKey = key;
			textBuf.push(partText);
			continue;
		}

		flushText();

		if (part.type === "tool_call") {
			// Try to find matching tool_result by toolCallId first, then fallback to name
			const matchedResult =
				toolResults.get(part.toolCallId) || toolResultsByName.get(part.name);
			segments.push({
				key,
				type: "tool_call",
				part,
				toolResult: matchedResult,
				timestamp,
			});
		} else if (part.type === "tool_result") {
			// Render only if we don't have a corresponding tool_call
			if (!toolCallIds.has(part.toolCallId)) {
				segments.push({
					key,
					type: "tool_result_only",
					part,
					timestamp,
				});
			}
		} else if (part.type === "thinking") {
			segments.push({
				key,
				type: "thinking",
				text: (part as { text?: string }).text ?? "",
				timestamp,
			});
		} else if (part.type === "error") {
			segments.push({
				key,
				type: "error",
				text: (part as { text?: string }).text ?? "",
				timestamp,
			});
		} else if (part.type === "compaction") {
			segments.push({
				key,
				type: "compaction",
				text: (part as { text?: string }).text ?? "",
				timestamp,
			});
		}
	}
	flushText();

	// A2UI surfaces are appended after all message parts.
	// Give them indices that sort after regular parts.
	const surfaceBase = (group.messages.length + 1) * 1_000_000;
	for (const [surfIdx, surface] of a2uiSurfaces.entries()) {
		segments.push({
			key: `a2ui-${surface.surfaceId}`,
			type: "a2ui",
			surface,
			timestamp: surfaceBase + surfIdx,
		});
	}

	segments.sort((a, b) => a.timestamp - b.timestamp);

	const normalizedSegments: Segment[] = [];
	for (let i = 0; i < segments.length; i++) {
		const segment = segments[i];
		if (segment.type === "tool_call") {
			let toolResult = segment.toolResult;
			if (!toolResult) {
				const next = segments[i + 1];
				if (next?.type === "tool_result_only") {
					toolResult = next.part;
					i += 1;
				}
			}
			normalizedSegments.push(
				toolResult && !segment.toolResult
					? { ...segment, toolResult }
					: segment,
			);
			continue;
		}
		normalizedSegments.push(segment);
	}

	type RenderSegment =
		| Segment
		| {
				key: string;
				type: "tool_group";
				segments: Array<
					| Extract<Segment, { type: "tool_call" }>
					| Extract<Segment, { type: "tool_result_only" }>
				>;
				timestamp: number;
		  };

	const renderSegments: RenderSegment[] = (() => {
		if (verbosity === 1) {
			const grouped: RenderSegment[] = [];
			let toolBuffer: Extract<
				RenderSegment,
				{ type: "tool_group" }
			>["segments"] = [];
			let thinkingBuffer: string[] = [];
			let thinkingKey: string | null = null;
			let thinkingTimestamp = 0;

			const flushRun = () => {
				if (thinkingBuffer.length > 0) {
					grouped.push({
						key: thinkingKey ?? `thinking-${grouped.length}`,
						type: "thinking",
						text: thinkingBuffer.join("\n\n"),
						timestamp: thinkingTimestamp,
					});
					thinkingBuffer = [];
					thinkingKey = null;
					thinkingTimestamp = 0;
				}
				if (toolBuffer.length > 0) {
					grouped.push({
						key: `tool-group-${toolBuffer[0].key}`,
						type: "tool_group",
						segments: toolBuffer,
						timestamp: toolBuffer[0].timestamp,
					});
					toolBuffer = [];
				}
			};

			for (const segment of normalizedSegments) {
				if (segment.type === "thinking") {
					if (thinkingBuffer.length === 0) {
						thinkingKey = segment.key;
						thinkingTimestamp = segment.timestamp;
					}
					thinkingBuffer.push(segment.text);
					continue;
				}
				if (
					segment.type === "tool_call" ||
					segment.type === "tool_result_only"
				) {
					toolBuffer.push(segment);
					continue;
				}
				flushRun();
				grouped.push(segment);
			}
			flushRun();
			return grouped;
		}
		if (verbosity !== 2) return normalizedSegments;
		const grouped: RenderSegment[] = [];
		let toolBuffer: Extract<RenderSegment, { type: "tool_group" }>["segments"] =
			[];
		let thinkingBuffer: string[] = [];
		let thinkingKey: string | null = null;
		let thinkingTimestamp = 0;

		const flushThinking = () => {
			if (thinkingBuffer.length === 0) return;
			grouped.push({
				key: thinkingKey ?? `thinking-${grouped.length}`,
				type: "thinking",
				text: thinkingBuffer.join("\n\n"),
				timestamp: thinkingTimestamp,
			});
			thinkingBuffer = [];
			thinkingKey = null;
			thinkingTimestamp = 0;
		};

		const flushTools = () => {
			if (toolBuffer.length === 0) return;
			if (toolBuffer.length === 1) {
				grouped.push(toolBuffer[0]);
			} else {
				grouped.push({
					key: `tool-group-${toolBuffer[0].key}`,
					type: "tool_group",
					segments: toolBuffer,
					timestamp: toolBuffer[0].timestamp,
				});
			}
			toolBuffer = [];
		};

		const flushRun = () => {
			flushThinking();
			flushTools();
		};

		for (const segment of normalizedSegments) {
			if (segment.type === "tool_call" || segment.type === "tool_result_only") {
				toolBuffer.push(segment);
				continue;
			}
			if (segment.type === "thinking") {
				if (thinkingBuffer.length === 0) {
					thinkingKey = segment.key;
					thinkingTimestamp = segment.timestamp;
				}
				thinkingBuffer.push(segment.text);
				continue;
			}
			flushRun();
			grouped.push(segment);
		}
		flushRun();
		return grouped;
	})();

	const allTextContent = segments
		.filter((s): s is Extract<Segment, { type: "text" }> => s.type === "text")
		.map((s) => s.text)
		.join("\n\n");

	// Use workspace name instead of "Assistant" when assistantName is not provided
	const workspaceName = workspacePath?.split("/").pop() || "Assistant";
	const assistantDisplayName = assistantName || workspaceName;

	const messageCard = (
		<div
			data-message-id={messageId}
			className={cn(
				"group transition-all duration-200 overflow-hidden",
				isUser
					? "sm:ml-8 bg-primary/20 dark:bg-primary/10 border border-primary/40 dark:border-primary/30"
					: "sm:mr-8 bg-muted/50 border border-border",
			)}
		>
			<div
				className={cn(
					"compact-header flex items-center gap-1 sm:gap-2 px-2 sm:px-3 py-1.5 sm:py-2 border-b",
					isUser ? "border-primary/30 dark:border-primary/20" : "border-border",
				)}
			>
				{isUser ? (
					<User className="w-3 h-3 sm:w-4 sm:h-4 text-primary flex-shrink-0" />
				) : (
					<Bot className="w-3 h-3 sm:w-4 sm:h-4 text-primary flex-shrink-0" />
				)}
				{isUser ? (
					<span className="text-sm font-medium text-foreground">You</span>
				) : (
					<span className="text-sm font-medium text-foreground">
						{assistantDisplayName}
						{tempIdLabel && (
							<span className="text-[9px] text-muted-foreground/70 ml-1">
								[{tempIdLabel}]
							</span>
						)}
					</span>
				)}
				{group.messages.length > 1 && (
					<span
						className={cn(
							"text-[9px] sm:text-[10px] px-1 border leading-none",
							isUser
								? "border-primary/30 text-primary"
								: "border-border text-muted-foreground",
						)}
					>
						{group.messages.length}
					</span>
				)}
				<div className="flex-1" />
				{!isUser && allTextContent && (
					<ReadAloudButton text={allTextContent} className="ml-1" />
				)}
				{createdAt && !Number.isNaN(createdAt.getTime()) && (
					<span className="text-[9px] sm:text-[10px] text-foreground/50 dark:text-muted-foreground leading-none sm:leading-normal ml-2">
						{createdAt.toLocaleTimeString([], {
							hour: "2-digit",
							minute: "2-digit",
						})}
					</span>
				)}
				{allTextContent && (
					<CopyButton
						text={allTextContent}
						className="hidden sm:inline-flex ml-1 [&_svg]:w-3 [&_svg]:h-3"
					/>
				)}
				{allTextContent && (
					<CompactCopyButton text={allTextContent} className="sm:hidden ml-1" />
				)}
			</div>

			<div className="px-2 sm:px-4 py-2 sm:py-3 group space-y-2 overflow-hidden">
				{renderSegments.length === 0 && !isUser && showWorkingIndicator && (
					<div className="flex items-center gap-3 text-muted-foreground text-sm">
						<BrailleSpinner />
						<span>{t("chat.working")}</span>
					</div>
				)}
				{renderSegments.length === 0 && isUser && (
					<span className="text-muted-foreground italic text-sm">
						No content
					</span>
				)}

				{renderSegments.map((segment, idx) => {
					const prevSegment = idx > 0 ? renderSegments[idx - 1] : null;
					const needsTopMargin =
						prevSegment?.type === "text" && segment.type !== "text";

					if (segment.type === "text") {
						return (
							<TextWithFileReferences
								key={segment.key}
								content={segment.text}
								workspacePath={workspacePath}
								locale={locale}
							/>
						);
					}
					if (segment.type === "tool_call") {
						return (
							<div
								key={segment.key}
								className={needsTopMargin ? "mt-2" : undefined}
							>
								<PiPartRenderer
									part={segment.part}
									toolResult={segment.toolResult}
									locale={locale}
									workspacePath={workspacePath}
								/>
							</div>
						);
					}
					if (segment.type === "tool_result_only") {
						// Render standalone tool result (no matching tool_use found)
						return (
							<div
								key={segment.key}
								className={needsTopMargin ? "mt-2" : undefined}
							>
								<PiPartRenderer
									part={segment.part}
									locale={locale}
									workspacePath={workspacePath}
								/>
							</div>
						);
					}
					if (segment.type === "thinking") {
						return (
							<div
								key={segment.key}
								className={needsTopMargin ? "mt-3" : undefined}
							>
								<PiPartRenderer
									part={{
										type: "thinking",
										id: segment.key,
										text: segment.text,
										__verbosity: verbosity,
									} as DisplayPart}
									locale={locale}
									workspacePath={workspacePath}
								/>
							</div>
						);
					}
					if (segment.type === "error") {
						return (
							<div
								key={segment.key}
								className={cn(
									"rounded-md border border-red-500/30 bg-red-500/10 px-3 py-2 text-sm text-red-600",
									needsTopMargin && "mt-3",
								)}
							>
								{segment.text}
							</div>
						);
					}
					if (segment.type === "compaction") {
						const isLoading = segment.text === "Compacting context...";
						return (
							<div
								key={segment.key}
								className={cn(
									"flex items-center gap-2 my-3 text-xs text-muted-foreground",
								)}
							>
								<div className="flex-1 h-px bg-border" />
								<div className="flex items-center gap-1.5 px-2 py-1 rounded-full bg-muted/50 border border-border/50">
									{isLoading ? (
										<svg
											className="animate-spin h-3 w-3"
											viewBox="0 0 24 24"
											fill="none"
										>
											<circle
												className="opacity-25"
												cx="12"
												cy="12"
												r="10"
												stroke="currentColor"
												strokeWidth="4"
											/>
											<path
												className="opacity-75"
												fill="currentColor"
												d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
											/>
										</svg>
									) : (
										<svg
											className="h-3 w-3"
											viewBox="0 0 24 24"
											fill="none"
											stroke="currentColor"
											strokeWidth="2"
										>
											<path d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.03 3-9s-1.343-9-3-9m0 18c-1.657 0-3-4.03-3-9s1.343-9 3-9" />
										</svg>
									)}
									<span>{segment.text}</span>
								</div>
								<div className="flex-1 h-px bg-border" />
							</div>
						);
					}
					if (segment.type === "tool_group") {
						const toolItems =
							verbosity === 1
								? (() => {
										const collapsed: Array<{
											toolName: string;
											count: number;
											input?: Record<string, unknown>;
										}> = [];
										for (const toolSegment of segment.segments) {
											const toolName =
												toolSegment.type === "tool_call"
													? toolSegment.part.name
													: toolSegment.part.name || "result";
											const input =
												toolSegment.type === "tool_call"
													? (toolSegment.part.input as
															| Record<string, unknown>
															| undefined)
													: undefined;
											const last = collapsed[collapsed.length - 1];
											if (last && last.toolName === toolName) {
												last.count += 1;
												continue;
											}
											collapsed.push({ toolName, count: 1, input });
										}
										return collapsed.map((entry, index) => {
											const icon = getToolIcon(entry.toolName, entry.input);
											const summary = getToolSummary(entry.toolName, entry.input, locale);
											const baseLabel = summary ?? entry.toolName;
											return {
												id: `${entry.toolName}-${index}`,
												label:
													entry.count > 1
														? `${baseLabel} (${entry.count})`
														: baseLabel,
												icon: (
													<span className="relative inline-flex">
														{icon}
														{entry.count > 1 && (
															<span className="absolute -top-0.5 -right-0.5 w-3 h-3 bg-pink-500 text-white text-[8px] rounded-[2px] flex items-center justify-center border border-background">
																{entry.count}
															</span>
														)}
													</span>
												),
												render: () => null,
											};
										});
									})()
								: segment.segments.map((toolSegment) => {
										const toolName =
											toolSegment.type === "tool_call"
												? toolSegment.part.name
												: toolSegment.part.name || "result";
										const input =
											toolSegment.type === "tool_call"
												? (toolSegment.part.input as
														| Record<string, unknown>
														| undefined)
												: undefined;
										const summary = getToolSummary(toolName, input, locale);
										return {
											id: toolSegment.key,
											label: summary ?? toolName,
											icon: getToolIcon(toolName, input),
											render: () =>
												verbosity === 1 ? null : (
													<PiPartRenderer
														part={toolSegment.part}
														toolResult={
															toolSegment.type === "tool_call"
																? toolSegment.toolResult
																: undefined
														}
														locale={locale}
														workspacePath={workspacePath}
														collapsible={false}
														hideHeader={verbosity === 2}
													/>
												),
										};
									});
						return (
							<div
								key={segment.key}
								className={needsTopMargin ? "mt-2" : undefined}
							>
								<ToolCallGroup
									key={`${segment.key}-verbosity-${verbosity}`}
									mode={verbosity === 1 ? "bar" : "tabs"}
									items={toolItems}
									disableInteraction={verbosity === 1}
								/>
							</div>
						);
					}
					if (segment.type === "a2ui") {
						return (
							<div
								key={segment.key}
								className={needsTopMargin ? "mt-2" : undefined}
							>
								<A2UICallCard
									surfaceId={segment.surface.surfaceId}
									messages={segment.surface.messages}
									blocking={segment.surface.blocking}
									requestId={segment.surface.requestId}
									answered={segment.surface.answered}
									answeredAction={segment.surface.answeredAction}
									answeredAt={segment.surface.answeredAt}
									onAction={onA2UIAction}
									defaultCollapsed={segment.surface.answered}
								/>
							</div>
						);
					}
					return null;
				})}
			</div>
		</div>
	);

	return (
		<ContextMenu>
			<ContextMenuTrigger className="contents">
				{messageCard}
			</ContextMenuTrigger>
			<ContextMenuContent>
				{allTextContent && (
					<ContextMenuItem
						onClick={() => navigator.clipboard?.writeText(allTextContent)}
						className="gap-2"
					>
						<Copy className="w-4 h-4" />
						{t("chat.copyAll")}
					</ContextMenuItem>
				)}
			</ContextMenuContent>
		</ContextMenu>
	);
});

/**
 * Renders a single part of a Pi message.
 */
function PiPartRenderer({
	part,
	toolResult,
	locale,
	workspacePath,
	collapsible = true,
	hideHeader = false,
}: {
	part: DisplayPart;
	toolResult?: Extract<DisplayPart, { type: "tool_result" }>;
	locale: "en" | "de";
	workspacePath?: string | null;
	collapsible?: boolean;
	hideHeader?: boolean;
}) {
	const { t } = useTranslation();
	const stripAnsi = (value: string): string => value.replace(ANSI_RE, "");

	const formatToolResultOutput = (content: unknown): string | undefined => {
		const decodeBytes = (bytes: Uint8Array): string | undefined => {
			try {
				const text = new TextDecoder("utf-8", { fatal: false }).decode(bytes);
				const printable = text
					.split("")
					.filter(
						(ch) => ch === "\n" || ch === "\r" || ch === "\t" || ch >= " ",
					).length;
				if (text.length === 0) return "";
				if (printable / text.length < 0.7) {
					return undefined;
				}
				return text;
			} catch {
				return undefined;
			}
		};

		if (typeof content === "string") {
			// Try to parse the string as JSON — some tools (e.g. MCP) serialize
			// their output as a JSON string containing an array of content blocks
			// like [{"type":"tool_result","output":"..."}] or [{"type":"text","text":"..."}].
			// In that case we recurse to extract the readable text instead of
			// rendering raw JSON.
			const trimmed = content.trim();
			if (trimmed.startsWith("[") || trimmed.startsWith("{")) {
				try {
					const parsed: unknown = JSON.parse(trimmed);
					if (Array.isArray(parsed) || (parsed && typeof parsed === "object")) {
						const extracted = formatToolResultOutput(parsed);
						if (extracted !== undefined) return extracted;
					}
				} catch {
					// not valid JSON — fall through to return the raw string
				}
			}
			return stripAnsi(content);
		}
		if (content instanceof Uint8Array) {
			return (
				decodeBytes(content) ?? `[binary data: ${content.byteLength} bytes]`
			);
		}
		if (Array.isArray(content)) {
			const byteArray =
				content.length > 0 && content.every((item) => typeof item === "number")
					? new Uint8Array(content as number[])
					: null;
			if (byteArray) {
				return (
					decodeBytes(byteArray) ??
					`[binary data: ${byteArray.byteLength} bytes]`
				);
			}
			const textBlocks = content
				.map((block) => {
					if (typeof block === "string") return block;
					if (!block || typeof block !== "object") return null;
					const b = block as Record<string, unknown>;
					if (b.type === "text" && typeof b.text === "string") return b.text;
					// Anthropic API tool_result block: { type: "tool_result", content: [...] }
					// Also handles MCP wrappers: { type: "tool_result", output: "..." }
					if (
						b.type === "tool_result" ||
						b.type === "toolResult" ||
						b.type === "tool_use"
					) {
						const inner =
							"content" in b ? b.content : "output" in b ? b.output : undefined;
						if (inner !== undefined) {
							return formatToolResultOutput(inner) ?? null;
						}
					}
					return null;
				})
				.filter((text): text is string => Boolean(text));
			if (textBlocks.length > 0) {
				return stripAnsi(textBlocks.join("\n\n"));
			}
		}
		if (content && typeof content === "object") {
			const obj = content as Record<string, unknown>;
			const base64 =
				(typeof obj.data_base64 === "string" && obj.data_base64) ||
				(typeof obj.content_base64 === "string" && obj.content_base64) ||
				(typeof obj.stdout_base64 === "string" && obj.stdout_base64) ||
				(typeof obj.bytes_base64 === "string" && obj.bytes_base64);
			if (base64) {
				try {
					const bytes = Uint8Array.from(atob(base64), (c) => c.charCodeAt(0));
					const decoded = decodeBytes(bytes);
					return decoded ?? `[binary data: ${bytes.byteLength} bytes]`;
				} catch {
					// fall through
				}
			}
			if (Array.isArray(obj.bytes)) {
				const bytes = new Uint8Array(
					obj.bytes.filter((item) => typeof item === "number") as number[],
				);
				return decodeBytes(bytes) ?? `[binary data: ${bytes.byteLength} bytes]`;
			}
			if (typeof obj.text === "string") return stripAnsi(obj.text);
			if (Array.isArray(obj.content)) {
				const nestedText = formatToolResultOutput(obj.content);
				if (nestedText) return nestedText;
			}
		}
		try {
			return stripAnsi(JSON.stringify(content, null, 2));
		} catch {
			return stripAnsi(String(content));
		}
	};

	switch (part.type) {
		case "text": {
			const textContent =
				(part as { text?: string; content?: string }).text ??
				(part as { content?: string }).content ??
				"";
			return (
				<TextWithFileReferences
					content={stripAnsi(textContent)}
					workspacePath={workspacePath}
					locale={locale}
				/>
			);
		}

		case "thinking": {
			const thinkingText = stripAnsi(
				((part as { text?: string }).text ?? "").trim(),
			);
			if (!thinkingText) return null;

			const verbosityLevel =
				typeof (part as Record<string, unknown>).__verbosity === "number"
					? ((part as Record<string, unknown>).__verbosity as 1 | 2 | 3)
					: 3;

			// Verbosity 3 (verbose): open by default, full markdown
			// Verbosity 2 (normal): collapsed, first-line preview
			// Verbosity 1 (compact): collapsed, just "Thinking" label
			const isOpen = verbosityLevel >= 3;
			// Always show first sentence preview when collapsed
			const firstSentence = (() => {
				const match = thinkingText.match(/^[^\n.!?]*[.!?]?/);
				const raw = match ? match[0].trim() : thinkingText.split("\n")[0];
				return raw.length > 140 ? `${raw.slice(0, 140)}...` : raw;
			})();
			const summaryLabel = t("chat.thinking");

			return (
				<details
					open={isOpen}
					className="group my-2 border-l-2 border-primary/40 bg-muted/40 pl-0"
				>
					<summary className="flex items-center gap-2 cursor-pointer select-none px-3 py-2 text-xs text-foreground/70 hover:text-foreground list-none [&::-webkit-details-marker]:hidden [&::marker]:content-['']">
						<svg
							className="h-3.5 w-3.5 shrink-0 transition-transform group-open:rotate-90"
							viewBox="0 0 24 24"
							fill="none"
							stroke="currentColor"
							strokeWidth="2"
							strokeLinecap="round"
							strokeLinejoin="round"
						>
							<polyline points="9 18 15 12 9 6" />
						</svg>
						<span className="font-medium">{summaryLabel}</span>
						{firstSentence && (
							<span className="truncate opacity-60 group-open:hidden">
								-- {firstSentence}
							</span>
						)}
					</summary>
					<div className="px-3 pb-3 pt-1 text-xs leading-relaxed">
						<MarkdownRenderer
							content={thinkingText}
							className="text-xs text-foreground/70 leading-relaxed [&_p]:text-foreground/70 [&_li]:text-foreground/70 [&_code]:text-foreground/60"
						/>
					</div>
				</details>
			);
		}

		case "tool_call": {
			const hasResult = Boolean(toolResult);
			const toolStatus = hasResult ? "completed" : "running";
			return (
				<ToolCallCard
					part={{
						id: part.id,
						sessionID: "",
						messageID: "",
						type: "tool",
						tool: part.name,
						callID: part.toolCallId,
						state: {
							status: toolStatus,
							input: part.input as Record<string, unknown>,
							output: toolResult
								? formatToolResultOutput(toolResult.output)
								: undefined,
							title: part.name,
						},
					}}
					defaultCollapsed={true}
					hideTodoTools={true}
					collapsible={collapsible}
					hideHeader={hideHeader}
				/>
			);
		}

		case "tool_result":
			// Tool results rendered standalone (no matching tool_call found)
			return (
				<ToolCallCard
					part={{
						id: part.id,
						sessionID: "",
						messageID: "",
						type: "tool",
						tool: part.name || "result",
						callID: part.toolCallId,
						state: {
							status: "completed",
							output: formatToolResultOutput(part.output),
							title: part.name || "Tool Result",
						},
					}}
					defaultCollapsed={true}
					hideTodoTools={true}
					collapsible={collapsible}
					hideHeader={hideHeader}
				/>
			);

		case "image": {
			const imgPart = part as Extract<DisplayPart, { type: "image" }>;
			let src = "";
			if (imgPart.source === "base64" && "data" in imgPart) {
				src = `data:${imgPart.mimeType ?? "image/png"};base64,${imgPart.data}`;
			} else if (imgPart.source === "url" && "url" in imgPart) {
				src = imgPart.url;
			}
			if (!src) return null;
			return (
				<img
					src={src}
					alt={imgPart.alt ?? "Attached content"}
					className="max-w-[300px] max-h-[300px] rounded-md border border-border object-contain"
					loading="lazy"
				/>
			);
		}

		default: {
			console.warn("Unknown Pi message part type:", part);
			return null;
		}
	}
}

/**
 * Renders text content with @file references as inline previews.
 * Wrapped in context menu for copy functionality on mobile.
 */
function TextWithFileReferences({
	content,
	workspacePath,
	locale = "en",
}: {
	content: string;
	workspacePath?: string | null;
	locale?: "en" | "de";
}) {
	// Strip ANSI escape codes and fix indentation before rendering.
	// Some models (e.g. Kimi-K2.5) prefix text with 4+ spaces which CommonMark
	// interprets as indented code blocks, causing plain text to render as <pre><code>.
	const cleanContent = dedentMarkdown(content.replace(ANSI_RE, ""));

	// Parse @file references, excluding code blocks
	const fileRefs = useMemo(
		() => extractFileReferenceDetails(cleanContent),
		[cleanContent],
	);

	return (
		<ContextMenu>
			<ContextMenuTrigger className="contents">
				<div className="space-y-2 select-none sm:select-auto">
					<MarkdownRenderer
						content={cleanContent}
						className="text-sm text-foreground leading-relaxed overflow-hidden"
					/>
					{/* Render file reference cards */}
					{fileRefs.length > 0 && workspacePath && (
						<div className="flex flex-wrap gap-2 mt-2">
							{fileRefs.map((ref) => (
								<FileReferenceCard
									key={`${ref.filePath}-${ref.label}`}
									filePath={ref.filePath}
									workspacePath={workspacePath}
									label={ref.label}
								/>
							))}
						</div>
					)}
				</div>
			</ContextMenuTrigger>
			<ContextMenuContent>
				<ContextMenuItem
					onClick={() => navigator.clipboard?.writeText(cleanContent)}
					className="gap-2"
				>
					<Copy className="w-4 h-4" />
					{t("chat.copy")}
				</ContextMenuItem>
			</ContextMenuContent>
		</ContextMenu>
	);
}

/**
 * Card for displaying a @file reference with preview.
 * Only renders if the file exists on disk.
 */
export const FileReferenceCard = memo(function FileReferenceCard({
	filePath,
	workspacePath,
	directUrl,
	label,
}: {
	filePath: string;
	workspacePath: string;
	directUrl?: string;
	label?: string;
}) {
	const [isLoading, setIsLoading] = useState(true);
	const [error, setError] = useState<string | null>(null);
	const [imageLoaded, setImageLoaded] = useState(false);
	const [fileExists, setFileExists] = useState<boolean | null>(null);
	const [fileUrl, setFileUrl] = useState<string | null>(null);
	const objectUrlRef = useRef<string | null>(null);

	const fileInfo = useMemo(() => getFileTypeInfo(filePath), [filePath]);
	const isImage = fileInfo.category === "image";
	const isVideo = fileInfo.category === "video";
	const fileName = label || filePath.split("/").pop() || filePath;

	useEffect(() => {
		let cancelled = false;
		setIsLoading(true);
		setError(null);
		setFileExists(null);
		setImageLoaded(false);
		setFileUrl(directUrl ?? null);

		if (objectUrlRef.current) {
			URL.revokeObjectURL(objectUrlRef.current);
			objectUrlRef.current = null;
		}

		if (!workspacePath && !directUrl) {
			setFileExists(false);
			setIsLoading(false);
			return;
		}

		const run = async () => {
			try {
				if (!directUrl && workspacePath) {
					await statPathMux(workspacePath, filePath);
				}

				if (cancelled) return;
				setFileExists(true);

				if ((isImage || isVideo) && !directUrl && workspacePath) {
					const result = await readFileMux(workspacePath, filePath);
					if (cancelled) return;
					const blob = new Blob([result.data]);
					const url = URL.createObjectURL(blob);
					objectUrlRef.current = url;
					setFileUrl(url);
				}
			} catch {
				if (cancelled) return;
				setFileExists(false);
				setError("File not found");
				setIsLoading(false);
			} finally {
				if (!cancelled && !isImage && !isVideo) {
					setIsLoading(false);
				}
			}
		};

		void run();
		return () => {
			cancelled = true;
			if (objectUrlRef.current) {
				URL.revokeObjectURL(objectUrlRef.current);
				objectUrlRef.current = null;
			}
		};
	}, [directUrl, filePath, isImage, isVideo, workspacePath]);

	// Don't render anything if file doesn't exist
	if (fileExists === false) {
		return null;
	}

	// Show loading state while checking existence
	if (fileExists === null) {
		return null;
	}

	if ((isImage || isVideo) && !fileUrl) {
		return null;
	}

	// For images, render inline preview
	if (isImage) {
		return (
			<div className="border border-border bg-muted/20 rounded overflow-hidden max-w-md">
				<div className="flex items-center gap-2 px-3 py-2 bg-muted/50 border-b border-border">
					<FileImage className="w-4 h-4 text-muted-foreground" />
					<span className="text-xs font-medium truncate">{fileName}</span>
				</div>
				<div className="relative">
					{isLoading && !imageLoaded && (
						<div className="flex items-center justify-center p-4">
							<Loader2 className="w-5 h-5 animate-spin text-muted-foreground" />
						</div>
					)}
					{error ? (
						<div className="flex items-center justify-center p-4 text-xs text-muted-foreground">
							{error}
						</div>
					) : (
						<img
							src={fileUrl ?? ""}
							alt={fileName}
							className={cn(
								"max-w-full h-auto",
								isLoading && !imageLoaded && "hidden",
							)}
							onLoad={() => {
								setImageLoaded(true);
								setIsLoading(false);
							}}
							onError={() => {
								setError("Failed to load image");
								setIsLoading(false);
							}}
						/>
					)}
				</div>
			</div>
		);
	}

	// Video preview
	if (isVideo) {
		return (
			<div className="border border-border bg-muted/20 rounded overflow-hidden max-w-md">
				<div className="flex items-center gap-2 px-3 py-2 bg-muted/50 border-b border-border">
					<FileVideo className="w-4 h-4 text-muted-foreground" />
					<span className="text-xs font-medium truncate">{fileName}</span>
				</div>
				<video
					src={fileUrl ?? ""}
					controls
					playsInline
					className="max-w-full h-auto"
					onLoadedData={() => setIsLoading(false)}
					onError={() => {
						setError("Failed to load video");
						setIsLoading(false);
					}}
				>
					<track kind="captions" />
					Your browser does not support the video tag.
				</video>
			</div>
		);
	}

	// For non-images/videos, render a compact file reference link
	const FileIcon = fileInfo.category === "code" ? FileCode : FileText;
	return (
		<button
			type="button"
			onClick={() => {
				if (directUrl) {
					window.open(directUrl, "_blank", "noopener");
					return;
				}
				if (!workspacePath) return;
				void downloadFileMux(workspacePath, filePath, fileName);
			}}
			className="inline-flex items-center gap-2 px-3 py-1.5 border border-border bg-muted/20 rounded hover:bg-muted/40 transition-colors text-sm"
		>
			<FileIcon className="w-4 h-4 text-muted-foreground" />
			<span className="font-medium">{fileName}</span>
			<span className="text-xs text-muted-foreground">{filePath}</span>
			<ExternalLink className="w-3 h-3 text-muted-foreground" />
		</button>
	);
});

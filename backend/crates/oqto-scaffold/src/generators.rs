//! Project generation logic.

use std::path::{Path, PathBuf};
use std::process::Command;

use anyhow::{Context, Result};
use tracing::info;

use crate::Tier;
use crate::templates::copy_template;
use crate::tiers::ScaffoldConfig;

/// Configuration for creating a new project.
pub struct ProjectConfig {
    pub name: String,
    pub tier: Tier,
    pub template: Option<String>,
    pub skills: Vec<String>,
    pub output_dir: PathBuf,
    pub init_git: bool,
    pub init_trx: bool,
}

/// Create a new project with the given configuration.
pub fn create_project(config: &ProjectConfig, scaffold_config: &ScaffoldConfig) -> Result<()> {
    info!(
        "Creating project '{}' with tier '{}'",
        config.name, config.tier
    );

    // Check if output directory already exists
    if config.output_dir.exists() {
        anyhow::bail!("Directory already exists: {}", config.output_dir.display());
    }

    // Create base directory
    std::fs::create_dir_all(&config.output_dir)
        .with_context(|| format!("creating directory: {}", config.output_dir.display()))?;

    // Copy template if specified
    if let Some(template_name) = &config.template {
        copy_template_to_project(template_name, &config.output_dir, scaffold_config)?;
    }

    // Generate .oqto/ directory with sandbox.toml
    generate_octo_config(config, scaffold_config)?;

    // Generate .opencode/ directory with opencode.json
    generate_opencode_config(config, scaffold_config)?;

    // Generate AGENTS.md
    generate_agents_md(config, scaffold_config)?;

    // Initialize git
    if config.init_git {
        init_git(&config.output_dir)?;
    }

    // Run ignr to generate .gitignore
    run_ignr(&config.output_dir)?;

    // Initialize trx
    if config.init_trx {
        init_trx(&config.output_dir)?;
    }

    info!("Project '{}' created successfully!", config.name);
    println!("\nProject created: {}", config.output_dir.display());
    println!("  Tier: {}", config.tier);
    if let Some(template) = &config.template {
        println!("  Template: {}", template);
    }
    if !config.skills.is_empty() {
        println!("  Skills: {}", config.skills.join(", "));
    }
    println!("\nNext steps:");
    println!("  cd {}", config.output_dir.display());
    println!("  opencode");

    Ok(())
}

fn copy_template_to_project(
    template_name: &str,
    output_dir: &Path,
    scaffold_config: &ScaffoldConfig,
) -> Result<()> {
    let templates_path = scaffold_config
        .templates_path()
        .ok_or_else(|| anyhow::anyhow!("No templates directory configured"))?;

    let template_path = templates_path.join(template_name);
    if !template_path.exists() {
        anyhow::bail!(
            "Template '{}' not found in {}",
            template_name,
            templates_path.display()
        );
    }

    info!(
        "Copying template '{}' from {}",
        template_name,
        template_path.display()
    );
    copy_template(&template_path, output_dir)?;

    Ok(())
}

fn generate_octo_config(config: &ProjectConfig, scaffold_config: &ScaffoldConfig) -> Result<()> {
    let octo_dir = config.output_dir.join(".oqto");
    std::fs::create_dir_all(&octo_dir)?;

    // Generate sandbox.toml from tier config
    let tier_config = scaffold_config.get_tier(config.tier);
    let sandbox_toml =
        toml::to_string_pretty(&tier_config.sandbox).context("serializing sandbox config")?;

    let sandbox_path = octo_dir.join("sandbox.toml");
    std::fs::write(
        &sandbox_path,
        format!(
            "# Sandbox configuration for tier: {}\n# Generated by oqto-scaffold\n\n{}",
            config.tier, sandbox_toml
        ),
    )
    .with_context(|| format!("writing {}", sandbox_path.display()))?;

    info!("Generated .oqto/sandbox.toml");

    Ok(())
}

fn generate_opencode_config(
    config: &ProjectConfig,
    scaffold_config: &ScaffoldConfig,
) -> Result<()> {
    let opencode_dir = config.output_dir.join(".opencode");
    std::fs::create_dir_all(&opencode_dir)?;

    let tier_config = scaffold_config.get_tier(config.tier);
    let opencode_json = serde_json::to_string_pretty(&tier_config.opencode)
        .context("serializing opencode config")?;

    let opencode_path = opencode_dir.join("opencode.json");
    std::fs::write(&opencode_path, opencode_json)
        .with_context(|| format!("writing {}", opencode_path.display()))?;

    info!("Generated .opencode/opencode.json");
    Ok(())
}

fn generate_agents_md(config: &ProjectConfig, scaffold_config: &ScaffoldConfig) -> Result<()> {
    let tier_config = scaffold_config.get_tier(config.tier);

    let agents_md = format!(
        r#"# {}

## Project Overview

<!-- Describe your project here -->

## Development Guidelines

<!-- Add project-specific instructions for AI agents -->

## Permission Tier

This project uses the **{}** permission tier:
{}

## Skills

{}

---
*Generated by oqto-scaffold*
"#,
        config.name,
        config.tier,
        tier_config.description,
        if config.skills.is_empty() {
            "No specific skills configured.".to_string()
        } else {
            format!("Enabled skills: {}", config.skills.join(", "))
        }
    );

    let agents_path = config.output_dir.join("AGENTS.md");
    std::fs::write(&agents_path, agents_md)
        .with_context(|| format!("writing {}", agents_path.display()))?;

    info!("Generated AGENTS.md");
    Ok(())
}

fn init_git(dir: &Path) -> Result<()> {
    info!("Initializing git repository");

    let status = Command::new("git")
        .args(["init", "--initial-branch=main"])
        .current_dir(dir)
        .status()
        .context("running git init")?;

    if !status.success() {
        anyhow::bail!("git init failed");
    }

    Ok(())
}

fn run_ignr(dir: &Path) -> Result<()> {
    // Check if ignr is available
    if Command::new("ignr").arg("--version").output().is_err() {
        info!("ignr not found, skipping .gitignore generation");
        return Ok(());
    }

    info!("Running ignr to generate .gitignore");

    let status = Command::new("ignr")
        .args(["generate"])
        .current_dir(dir)
        .status()
        .context("running ignr")?;

    if !status.success() {
        // Not fatal, just warn
        tracing::warn!("ignr failed, continuing without .gitignore");
    }

    Ok(())
}

fn init_trx(dir: &Path) -> Result<()> {
    // Check if trx is available
    if Command::new("trx").arg("--version").output().is_err() {
        info!("trx not found, skipping issue tracker initialization");
        return Ok(());
    }

    info!("Initializing trx issue tracker");

    let status = Command::new("trx")
        .args(["init"])
        .current_dir(dir)
        .status()
        .context("running trx init")?;

    if !status.success() {
        // Not fatal, just warn
        tracing::warn!("trx init failed, continuing without issue tracker");
    }

    Ok(())
}
